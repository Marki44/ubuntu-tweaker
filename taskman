#!/usr/bin/env python3
# taskman — clean TUI task manager (Ubuntu 20/22/24, Python 3.8+)
#
# Keys:
#   ↑↓            Select process
#   Left click    Select process
#   Enter         Terminate (SIGTERM)
#   K             Kill (SIGKILL)
#   S             Sort (CPU → MEM → PID → NAME)   (stable list)
#   D             Dynamic ON/OFF (when ON: auto-refresh + auto-resort)
#   /             Search (inline box under processes)
#   R             Refresh processes (manual)
#   Q             Exit

import os
import sys
import time
import curses
import shutil
import signal


REFRESH_SYS_SEC = 1.0
DYNAMIC_PROC_SEC = 1.0
UI_FPS = 12
MAX_PROCS_SCAN = 7000


def clamp(n, lo, hi):
    return lo if n < lo else hi if n > hi else n


def read_text(path, default=""):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception:
        return default


def read_first_line(path, default=""):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.readline().strip()
    except Exception:
        return default


def ellipsize(s, w):
    if w <= 0:
        return ""
    if len(s) <= w:
        return s
    if w <= 1:
        return s[:w]
    return s[:w - 1] + "…"


def human_bytes_dec(n):
    try:
        n = float(n)
    except Exception:
        return "0B"
    units = ["B", "KB", "MB", "GB", "TB"]
    u = 0
    while n >= 1000.0 and u < len(units) - 1:
        n /= 1000.0
        u += 1
    if u == 0:
        return f"{int(n)}{units[u]}"
    if units[u] in ("GB", "TB"):
        return f"{n:.2f}{units[u]}"
    return f"{n:.1f}{units[u]}"


def human_rate_dec(nps):
    return f"{human_bytes_dec(nps)}/s"


def meter_caps(width_inner, pct):
    pct = clamp(pct, 0.0, 100.0)
    fill = int(round((pct / 100.0) * width_inner))
    fill = clamp(fill, 0, width_inner)
    inner = ("█" * fill) + ("░" * (width_inner - fill))
    return "▕" + inner + "▏"


def get_hostname():
    try:
        return os.uname().nodename
    except Exception:
        return "host"


def get_kernel():
    try:
        return os.uname().release
    except Exception:
        return "?"


def get_os_pretty():
    data = read_text("/etc/os-release", "")
    for line in data.splitlines():
        if line.startswith("PRETTY_NAME="):
            return line.split("=", 1)[1].strip().strip('"')
    for line in data.splitlines():
        if line.startswith("NAME="):
            return line.split("=", 1)[1].strip().strip('"')
    return "Linux"


def get_cpu_model():
    txt = read_text("/proc/cpuinfo", "")
    for line in txt.splitlines():
        if ":" not in line:
            continue
        k, v = line.split(":", 1)
        if k.strip().lower() == "model name":
            return v.strip()
    return "CPU"


def get_uptime_str():
    up = read_first_line("/proc/uptime", "0 0").split()
    try:
        sec = int(float(up[0]))
    except Exception:
        sec = 0
    days = sec // 86400
    sec %= 86400
    hh = sec // 3600
    sec %= 3600
    mm = sec // 60
    ss = sec % 60
    if days > 0:
        return f"{days}d {hh:02d}:{mm:02d}:{ss:02d}"
    return f"{hh:02d}:{mm:02d}:{ss:02d}"


def get_loadavg3():
    s = read_first_line("/proc/loadavg", "0 0 0 0/0 0").split()
    return (s[0], s[1], s[2]) if len(s) >= 3 else ("0", "0", "0")


def _base_block(dev_path):
    name = dev_path.strip().split("/")[-1]
    if name.startswith("nvme") and "p" in name:
        return name.split("p", 1)[0]
    while name and name[-1].isdigit():
        name = name[:-1]
    return name


def root_mount_info():
    dev = ""
    fstype = ""
    mounts = read_text("/proc/mounts", "")
    for line in mounts.splitlines():
        parts = line.split()
        if len(parts) >= 3 and parts[1] == "/":
            dev = parts[0]
            fstype = parts[2]
            break
    return dev, fstype


def root_disk_hardware():
    dev, fstype = root_mount_info()
    if not dev.startswith("/dev/"):
        return {"dev": dev or "?", "fstype": fstype or "?", "type": "?", "model": "?"}

    base = _base_block(dev)
    rotational = read_first_line(f"/sys/class/block/{base}/queue/rotational", "")
    disk_type = "SSD" if rotational.strip() == "0" else "HDD" if rotational.strip() == "1" else "Disk"
    model = read_first_line(f"/sys/class/block/{base}/device/model", "")
    if not model:
        model = read_first_line(f"/sys/class/block/{base}/device/name", "")
    if not model:
        model = base

    return {"dev": dev, "fstype": fstype or "?", "type": disk_type, "model": model}


def safe_addnstr(stdscr, y, x, s, n, attr=0):
    try:
        h, w = stdscr.getmaxyx()
        if y < 0 or y >= h or x < 0 or x >= w:
            return
        # clamp to screen width (no "-1" so we don't under-print borders)
        maxn = max(0, min(n, w - x))
        if maxn <= 0:
            return
        if attr:
            stdscr.attron(attr)
        stdscr.addnstr(y, x, s, maxn)
        if attr:
            stdscr.attroff(attr)
    except curses.error:
        return


def safe_fill(stdscr, y, x, n, attr=0):
    safe_addnstr(stdscr, y, x, " " * max(0, n), n, attr)


def draw_box(stdscr, y, x, h, w, title, attr_border, attr_title, bg_attr):
    if h < 3 or w < 6:
        return
    safe_addnstr(stdscr, y, x, "┌" + "─" * (w - 2) + "┐", w, attr_border)
    safe_addnstr(stdscr, y + h - 1, x, "└" + "─" * (w - 2) + "┘", w, attr_border)
    for yy in range(y + 1, y + h - 1):
        safe_addnstr(stdscr, yy, x, "│", 1, attr_border)
        safe_addnstr(stdscr, yy, x + w - 1, "│", 1, attr_border)
        safe_fill(stdscr, yy, x + 1, w - 2, bg_attr)
    if title:
        t = f" {title} "
        safe_addnstr(stdscr, y, x + 2, ellipsize(t, w - 4), w - 4, attr_title)


def read_cpu_total_idle():
    line = read_first_line("/proc/stat", "")
    if not line.startswith("cpu "):
        return 0, 0
    parts = line.split()[1:]
    vals = []
    for x in parts:
        try:
            vals.append(int(x))
        except Exception:
            vals.append(0)
    total = sum(vals)
    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
    return total, idle


def read_meminfo_kb():
    out = {}
    for line in read_text("/proc/meminfo").splitlines():
        if ":" not in line:
            continue
        k, v = line.split(":", 1)
        v = v.strip().split()
        if not v:
            continue
        try:
            out[k] = int(v[0])
        except Exception:
            pass
    return out


def disk_usage_root():
    try:
        du = shutil.disk_usage("/")
        return du.total, du.used, du.free
    except Exception:
        return 0, 0, 0


def read_net_bytes_total():
    rx = 0
    tx = 0
    for line in read_text("/proc/net/dev").splitlines():
        if ":" not in line:
            continue
        iface, rest = line.split(":", 1)
        iface = iface.strip()
        if iface == "lo":
            continue
        cols = rest.split()
        if len(cols) < 16:
            continue
        try:
            rx += int(cols[0])
            tx += int(cols[8])
        except Exception:
            pass
    return rx, tx


def list_pids():
    out = []
    try:
        for name in os.listdir("/proc"):
            if name.isdigit():
                out.append(int(name))
    except Exception:
        return []
    out.sort()
    return out[:MAX_PROCS_SCAN]


def read_proc_stat_ticks(pid):
    s = read_text(f"/proc/{pid}/stat", "")
    if not s:
        return None
    r = s.rfind(")")
    if r == -1:
        return None
    after = s[r + 2 :].split()
    if len(after) < 13:
        return None
    try:
        ut = int(after[11])
        st = int(after[12])
        return ut + st
    except Exception:
        return None


def read_proc_rss_kb(pid):
    for line in read_text(f"/proc/{pid}/status").splitlines():
        if line.startswith("VmRSS:"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    return int(parts[1])
                except Exception:
                    return 0
    return 0


def read_proc_uid(pid):
    for line in read_text(f"/proc/{pid}/status").splitlines():
        if line.startswith("Uid:"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    return int(parts[1])
                except Exception:
                    return None
    return None


_UID_MAP = None


def uid_to_user(uid):
    global _UID_MAP
    if uid is None:
        return "?"
    if _UID_MAP is None:
        _UID_MAP = {}
        for line in read_text("/etc/passwd").splitlines():
            if ":" not in line:
                continue
            p = line.split(":")
            if len(p) >= 3:
                try:
                    _UID_MAP[int(p[2])] = p[0]
                except Exception:
                    pass
    return _UID_MAP.get(uid, str(uid))


def read_proc_cmd(pid):
    cmdline = read_text(f"/proc/{pid}/cmdline")
    if cmdline:
        s = cmdline.replace("\x00", " ").strip()
        if s:
            return s
    comm = read_first_line(f"/proc/{pid}/comm", "")
    return comm if comm else str(pid)


class TaskMan:
    def __init__(self):
        # default: cpu sort, stable list
        self.sort_mode = "CPU"
        self.dynamic_sort = False
        self.search_text = ""

        self.selected = 0
        self.view_scroll = 0

        self.toast_msg = ""
        self.toast_until = 0.0

        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        self.cpu_pct = 0.0

        self.prev_rx = 0
        self.prev_tx = 0
        self.rx_rate = 0.0
        self.tx_rate = 0.0

        self.prev_proc_ticks = {}
        self.prev_cpu_total_for_procs = 0

        self.sys = {}
        self.procs_by_pid = {}
        self.order = []
        self.view = []

        self.host = get_hostname()
        self.os_name = get_os_pretty()
        self.kernel = get_kernel()
        self.cpu_model = get_cpu_model()
        self.cores = os.cpu_count() or 1
        self.disk_hw = root_disk_hardware()

        # inline search UI
        self.search_mode = False
        self.search_buf = ""

        # manual refresh flag
        self.proc_dirty = True

    def init_colors(self, stdscr):
        curses.start_color()
        try:
            curses.use_default_colors()
        except Exception:
            pass

        curses.init_pair(1, curses.COLOR_WHITE, -1)    # base
        curses.init_pair(2, curses.COLOR_CYAN, -1)     # headings
        curses.init_pair(3, curses.COLOR_MAGENTA, -1)  # accents
        curses.init_pair(4, curses.COLOR_YELLOW, -1)   # header highlight
        curses.init_pair(5, curses.COLOR_RED, -1)      # hot
        curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_WHITE)  # selected row
        curses.init_pair(7, curses.COLOR_WHITE, -1)    # subtle

        stdscr.bkgd(" ", curses.color_pair(1))
        stdscr.erase()

        try:
            curses.mousemask(curses.ALL_MOUSE_EVENTS)
            curses.mouseinterval(120)
        except Exception:
            pass

    def toast(self, msg, secs=1.1):
        self.toast_msg = msg
        self.toast_until = time.monotonic() + secs

    def pct_color(self, pct):
        if pct >= 90:
            return curses.color_pair(5) | curses.A_BOLD
        if pct >= 70:
            return curses.color_pair(4) | curses.A_BOLD
        return curses.color_pair(2)

    def refresh_system(self, dt):
        total, idle = read_cpu_total_idle()
        if self.prev_cpu_total:
            d_total = max(1, total - self.prev_cpu_total)
            d_idle = max(0, idle - self.prev_cpu_idle)
            self.cpu_pct = clamp((1.0 - (d_idle / d_total)) * 100.0, 0.0, 100.0)
        self.prev_cpu_total, self.prev_cpu_idle = total, idle

        mi = read_meminfo_kb()
        mem_total_kb = mi.get("MemTotal", 0)
        mem_avail_kb = mi.get("MemAvailable", 0)
        mem_used_kb = max(0, mem_total_kb - mem_avail_kb)
        mem_pct = (mem_used_kb / mem_total_kb * 100.0) if mem_total_kb else 0.0

        swap_total_kb = mi.get("SwapTotal", 0)
        swap_free_kb = mi.get("SwapFree", 0)
        swap_used_kb = max(0, swap_total_kb - swap_free_kb)

        d_total, d_used, _ = disk_usage_root()
        d_pct = (d_used / d_total * 100.0) if d_total else 0.0

        rx, tx = read_net_bytes_total()
        dt2 = max(1.0, dt)
        if self.prev_rx:
            self.rx_rate = max(0.0, (rx - self.prev_rx) / dt2)
        if self.prev_tx:
            self.tx_rate = max(0.0, (tx - self.prev_tx) / dt2)
        self.prev_rx, self.prev_tx = rx, tx

        load1, load5, load15 = get_loadavg3()
        self.sys = {
            "uptime": get_uptime_str(),
            "load": (load1, load5, load15),
            "cpu_pct": self.cpu_pct,

            "mem_used": mem_used_kb * 1024,
            "mem_total": mem_total_kb * 1024,
            "mem_pct": mem_pct,

            "swap_used": swap_used_kb * 1024,
            "swap_total": swap_total_kb * 1024,

            "disk_used": d_used,
            "disk_total": d_total,
            "disk_pct": d_pct,

            "rx_rate": self.rx_rate,
            "tx_rate": self.tx_rate,
        }

    def _sort_items(self, items):
        if self.sort_mode == "MEM":
            items.sort(key=lambda x: (x["mem"], x["cpu"]), reverse=True)
        elif self.sort_mode == "PID":
            items.sort(key=lambda x: x["pid"])
        elif self.sort_mode == "NAME":
            items.sort(key=lambda x: x["cmd"].lower())
        else:
            items.sort(key=lambda x: (x["cpu"], x["mem"]), reverse=True)

    def refresh_processes(self):
        # heavier scan: only when requested OR when dynamic is ON
        pids = list_pids()
        cpu_total, _ = read_cpu_total_idle()
        total_delta = max(1, cpu_total - self.prev_cpu_total_for_procs) if self.prev_cpu_total_for_procs else 1
        self.prev_cpu_total_for_procs = cpu_total

        alive_set = set()

        for pid in pids:
            ticks = read_proc_stat_ticks(pid)
            if ticks is None:
                continue
            prev = self.prev_proc_ticks.get(pid, ticks)
            self.prev_proc_ticks[pid] = ticks
            proc_delta = max(0, ticks - prev)
            cpu_pct = (proc_delta / total_delta) * 100.0

            rss_kb = read_proc_rss_kb(pid)
            mem_bytes = rss_kb * 1024

            uid = read_proc_uid(pid)
            user = uid_to_user(uid)
            cmd = read_proc_cmd(pid)

            self.procs_by_pid[pid] = {
                "pid": pid,
                "user": user,
                "cpu": cpu_pct,
                "mem": mem_bytes,
                "cmd": cmd,
            }
            alive_set.add(pid)

        for pid in list(self.procs_by_pid.keys()):
            if pid not in alive_set:
                self.procs_by_pid.pop(pid, None)

        # keep old order by default (stable), unless first time
        if not self.order:
            items = list(self.procs_by_pid.values())
            self._sort_items(items)  # default sort once
            self.order = [p["pid"] for p in items]
        else:
            # keep existing order, append new pids to end
            known = set(self.order)
            for pid in self.procs_by_pid.keys():
                if pid not in known:
                    self.order.append(pid)

        # dynamic ON: re-sort every refresh
        if self.dynamic_sort:
            items = [self.procs_by_pid[pid] for pid in self.order if pid in self.procs_by_pid]
            self._sort_items(items)
            self.order = [p["pid"] for p in items]

        # build view with search
        stxt = self.search_text.lower().strip()
        view = []
        if stxt:
            for pid in self.order:
                p = self.procs_by_pid.get(pid)
                if not p:
                    continue
                if (stxt in p["cmd"].lower()) or (stxt in p["user"].lower()) or (stxt in str(pid)):
                    view.append(p)
        else:
            for pid in self.order:
                p = self.procs_by_pid.get(pid)
                if p:
                    view.append(p)

        self.view = view
        if self.selected >= len(self.view):
            self.selected = max(0, len(self.view) - 1)
        self.view_scroll = clamp(self.view_scroll, 0, max(0, len(self.view) - 1))

        self.proc_dirty = False

    def ensure_selected_visible(self, rows_avail):
        if not self.view:
            self.selected = 0
            self.view_scroll = 0
            return
        self.selected = clamp(self.selected, 0, len(self.view) - 1)
        if self.selected < self.view_scroll:
            self.view_scroll = self.selected
        if self.selected >= self.view_scroll + rows_avail:
            self.view_scroll = self.selected - rows_avail + 1
        max_scroll = max(0, len(self.view) - rows_avail)
        self.view_scroll = clamp(self.view_scroll, 0, max_scroll)

    def kill_pid(self, pid, sig):
        try:
            os.kill(pid, sig)
            return True, ""
        except PermissionError:
            return False, "permission denied"
        except ProcessLookupError:
            return False, "no such process"
        except Exception as e:
            return False, str(e)

    def cycle_sort(self):
        order = ["CPU", "MEM", "PID", "NAME"]
        i = order.index(self.sort_mode) if self.sort_mode in order else 0
        self.sort_mode = order[(i + 1) % len(order)]
        # stable sort applies once now (and stays stable)
        items = [self.procs_by_pid[pid] for pid in self.order if pid in self.procs_by_pid]
        self._sort_items(items)
        self.order = [p["pid"] for p in items]
        self.proc_dirty = True
        self.toast(f"sort: {self.sort_mode.lower()}")

    def toggle_dynamic(self):
        self.dynamic_sort = not self.dynamic_sort
        self.proc_dirty = True
        self.toast(f"dynamic: {'on' if self.dynamic_sort else 'off'}")

    def begin_search(self):
        self.search_mode = True
        self.search_buf = self.search_text or ""
        self.toast("search", 0.6)

    def cancel_search(self):
        self.search_mode = False
        self.search_buf = ""

    def apply_search(self):
        self.search_text = self.search_buf.strip()
        self.selected = 0
        self.view_scroll = 0
        self.search_mode = False
        self.proc_dirty = True
        self.toast("search set" if self.search_text else "search cleared")

    # -------------------- drawing --------------------

    def draw_header(self, stdscr, w):
        load1, load5, load15 = self.sys["load"]
        up = self.sys["uptime"]

        left = f"{self.host} — Task Manager"
        right = f"CPU {self.sys['cpu_pct']:.1f}%  •  Load {load1} {load5} {load15}  •  Uptime {up}"

        safe_fill(stdscr, 0, 0, w, curses.color_pair(1))
        safe_addnstr(stdscr, 0, 2, ellipsize(left, w // 2), w // 2, curses.color_pair(2) | curses.A_BOLD)
        safe_addnstr(stdscr, 0, max(2, w - len(right) - 2), right, len(right), curses.color_pair(2))

        left2 = f"{self.os_name}  •  Kernel {self.kernel}"
        cpu_short = ellipsize(self.cpu_model, max(28, w // 2 - 18))
        right2 = f"{cpu_short}  •  Cores {self.cores}"
        safe_fill(stdscr, 1, 0, w, curses.color_pair(1))
        safe_addnstr(stdscr, 1, 2, ellipsize(left2, w - 4), w - 4, curses.color_pair(7))
        safe_addnstr(stdscr, 1, max(2, w - len(right2) - 2), right2, len(right2), curses.color_pair(7))

        if self.toast_msg and time.monotonic() < self.toast_until:
            safe_fill(stdscr, 2, 0, w, curses.color_pair(1))
            safe_addnstr(stdscr, 2, 2, ellipsize(self.toast_msg, w - 4), w - 4, curses.color_pair(4) | curses.A_BOLD)
        else:
            self.toast_msg = ""
            safe_fill(stdscr, 2, 0, w, curses.color_pair(1))

    def draw_performance(self, stdscr, y, x, h, w):
        draw_box(stdscr, y, x, h, w, "PERFORMANCE",
                 curses.color_pair(2), curses.color_pair(2) | curses.A_BOLD, curses.color_pair(1))

        # tighter: start immediately inside border
        ix, iy = x + 2, y + 1
        iw = w - 4

        mem_total = self.sys["mem_total"]
        swap_total = self.sys["swap_total"]
        disk_dev = self.disk_hw.get("dev", "?")
        disk_type = self.disk_hw.get("type", "Disk")
        disk_model = self.disk_hw.get("model", "?")
        fs = self.disk_hw.get("fstype", "?")

        line_a = f"Memory: {human_bytes_dec(mem_total)}  •  Swap: {human_bytes_dec(swap_total)}"
        line_b = f"Disk: {disk_type} {disk_model}  •  {disk_dev}  •  {fs}"

        safe_addnstr(stdscr, iy + 1, ix, ellipsize(line_a, iw), iw, curses.color_pair(7))
        safe_addnstr(stdscr, iy + 2, ix, ellipsize(line_b, iw), iw, curses.color_pair(7))

        inner = max(18, min(26, iw - 52))

        mem_used = self.sys["mem_used"]
        mem_pct = self.sys["mem_pct"]
        cpu_pct = self.sys["cpu_pct"]
        d_used = self.sys["disk_used"]
        d_pct = self.sys["disk_pct"]
        rx = self.sys["rx_rate"]
        tx = self.sys["tx_rate"]

        def row(label, pct, extra, row_y):
            safe_addnstr(stdscr, row_y, ix, f"{label:<3}", 3, curses.color_pair(3) | curses.A_BOLD)
            bar = meter_caps(inner, pct)
            safe_addnstr(stdscr, row_y, ix + 5, bar, len(bar), self.pct_color(pct))
            safe_addnstr(stdscr, row_y, ix + 5 + len(bar) + 2, f"{pct:5.1f}%", 7, curses.color_pair(7))
            if extra:
                safe_addnstr(stdscr, row_y, ix + 5 + len(bar) + 10, extra, iw - (5 + len(bar) + 10), curses.color_pair(1))

        # order: MEM then CPU
        row("MEM", mem_pct, f"{human_bytes_dec(mem_used)} | {human_bytes_dec(mem_total)}", iy + 4)
        row("CPU", cpu_pct, "", iy + 6)
        row("DSK", d_pct, f"{human_bytes_dec(d_used)} | {human_bytes_dec(self.sys['disk_total'])}", iy + 8)

        net_line = f"NET  ↓ {human_rate_dec(rx)}   ↑ {human_rate_dec(tx)}"
        safe_addnstr(stdscr, iy + 10, ix, ellipsize(net_line, iw), iw, curses.color_pair(7))

    def draw_processes(self, stdscr, y, x, h, w):
        draw_box(stdscr, y, x, h, w, "PROCESSES",
                 curses.color_pair(2), curses.color_pair(2) | curses.A_BOLD, curses.color_pair(1))

        ix, iy = x + 2, y + 1
        iw = w - 4

        dyn = "on" if self.dynamic_sort else "off"
        sortname = self.sort_mode.lower()
        st = self.search_text if self.search_text else "—"
        status = f"sort {sortname}  •  dynamic {dyn}  •  search {st}"
        safe_addnstr(stdscr, iy, ix, ellipsize(status, iw), iw, curses.color_pair(7))

        # header row directly under status
        yy_hdr = iy + 2

        col_cpu = 7
        col_mem = 10
        col_pid = 8
        col_user = 10
        col_name = iw - (col_cpu + col_mem + col_pid + col_user + 4)
        if col_name < 18:
            col_name = 18

        hdr = curses.color_pair(4) | curses.A_BOLD
        safe_addnstr(stdscr, yy_hdr, ix, "NAME", col_name, hdr)
        safe_addnstr(stdscr, yy_hdr, ix + col_name + 1, "CPU", col_cpu, hdr)
        safe_addnstr(stdscr, yy_hdr, ix + col_name + 1 + col_cpu + 1, "MEM", col_mem, hdr)
        safe_addnstr(stdscr, yy_hdr, ix + col_name + 1 + col_cpu + 1 + col_mem + 1, "PID", col_pid, hdr)
        safe_addnstr(stdscr, yy_hdr, ix + col_name + 1 + col_cpu + 1 + col_mem + 1 + col_pid + 1, "USER", col_user, hdr)

        # rows area
        rows_y = yy_hdr + 1
        # inside height is (h-2) lines; we used 1 status + 1 blank + 1 header => rows start at iy+3
        rows_avail = max(1, (y + h - 1) - rows_y)  # up to inside bottom
        self.ensure_selected_visible(rows_avail)

        n = len(self.view)
        max_scroll = max(0, n - rows_avail)
        self.view_scroll = clamp(self.view_scroll, 0, max_scroll)

        for i in range(rows_avail):
            idx = self.view_scroll + i
            yy = rows_y + i
            safe_fill(stdscr, yy, ix, iw, curses.color_pair(1))
            if idx >= n:
                continue

            p = self.view[idx]
            cmd = ellipsize(p["cmd"], col_name)
            cpu = p["cpu"]
            mem = ellipsize(human_bytes_dec(p["mem"]), col_mem)
            pid = str(p["pid"])
            user = ellipsize(p["user"], col_user)

            selected = (idx == self.selected)
            if selected:
                row_attr = curses.color_pair(6) | curses.A_BOLD
                safe_fill(stdscr, yy, ix, iw, row_attr)
                cpu_attr = row_attr
            else:
                row_attr = curses.color_pair(1)
                cpu_attr = self.pct_color(cpu)

            safe_addnstr(stdscr, yy, ix, cmd, col_name, row_attr)
            safe_addnstr(stdscr, yy, ix + col_name + 1, f"{cpu:5.1f}%", col_cpu, cpu_attr)
            safe_addnstr(stdscr, yy, ix + col_name + 1 + col_cpu + 1, mem, col_mem, row_attr)
            safe_addnstr(stdscr, yy, ix + col_name + 1 + col_cpu + 1 + col_mem + 1, ellipsize(pid, col_pid), col_pid, row_attr)
            safe_addnstr(stdscr, yy, ix + col_name + 1 + col_cpu + 1 + col_mem + 1 + col_pid + 1, user, col_user, row_attr)

    def draw_search_box(self, stdscr, y, x, h, w):
        draw_box(stdscr, y, x, h, w, "SEARCH",
                 curses.color_pair(2), curses.color_pair(2) | curses.A_BOLD, curses.color_pair(1))
        ix, iy = x + 2, y + 1
        iw = w - 4

        hint = "Type to search • Enter apply • Esc cancel"
        safe_addnstr(stdscr, iy, ix, ellipsize(hint, iw), iw, curses.color_pair(7))

        prompt = "> " + self.search_buf
        safe_addnstr(stdscr, iy + 1, ix, ellipsize(prompt, iw), iw, curses.color_pair(1) | curses.A_BOLD)
        try:
            curses.curs_set(1)
            stdscr.move(iy + 1, min(ix + 2 + len(self.search_buf), x + w - 2))
        except Exception:
            pass

    def draw_footer(self, stdscr, h, w):
        safe_fill(stdscr, h - 1, 0, w, curses.color_pair(1))
        key_attr = curses.color_pair(2) | curses.A_BOLD
        text_attr = curses.color_pair(7)

        parts = [
            ("Q", "Exit"),
            ("R", "Refresh Proc"),
            ("S", "Sort"),
            ("D", "Dynamic"),
            ("/", "Search"),
            ("Enter", "Terminate"),
            ("K", "Kill"),
            ("↑↓", "Select"),
            ("Click", "Select"),
        ]

        x = 2
        for k, label in parts:
            segk = f"[{k}]"
            segt = f" {label} "
            need = len(segk) + len(segt) + 2
            if x + need >= w - 1:
                break
            safe_addnstr(stdscr, h - 1, x, segk, len(segk), key_attr)
            x += len(segk)
            safe_addnstr(stdscr, h - 1, x, segt, len(segt), text_attr)
            x += len(segt)
            safe_addnstr(stdscr, h - 1, x, "│", 1, curses.color_pair(1))
            x += 2

    def layout(self, h, w):
        # header: 3 lines
        header_h = 3
        perf_h = 12
        footer_h = 1
        gap = h - (header_h + perf_h + footer_h + 3)  # 2 spacers + margins
        gap = max(8, gap)

        search_h = 4 if self.search_mode else 0
        proc_h = max(8, gap - search_h)

        header_y = 0
        perf_y = header_y + header_h
        perf_y += 0  # already placed
        perf_y = 3
        perf_x = 2
        perf_w = w - 4

        proc_y = perf_y + perf_h + 1
        proc_x = 2
        proc_w = w - 4

        search_y = proc_y + proc_h + 1

        return {
            "perf": (perf_y, perf_x, perf_h, perf_w),
            "proc": (proc_y, proc_x, proc_h, proc_w),
            "search": (search_y, 2, search_h, w - 4),
        }

    def run(self, stdscr):
        curses.curs_set(0)
        stdscr.keypad(True)
        stdscr.nodelay(True)

        self.init_colors(stdscr)

        self.prev_cpu_total, self.prev_cpu_idle = read_cpu_total_idle()
        self.prev_rx, self.prev_tx = read_net_bytes_total()

        last_sys = time.monotonic()
        last_draw = 0.0
        last_dyn_proc = 0.0

        self.refresh_system(REFRESH_SYS_SEC)
        self.refresh_processes()

        while True:
            now = time.monotonic()

            # always dynamic system stats
            if now - last_sys >= REFRESH_SYS_SEC:
                dt = now - last_sys
                last_sys = now
                self.refresh_system(max(1.0, dt))

            # processes: only refresh when dirty OR dynamic ON
            if self.dynamic_sort and (now - last_dyn_proc >= DYNAMIC_PROC_SEC):
                last_dyn_proc = now
                self.refresh_processes()
            elif self.proc_dirty:
                self.refresh_processes()

            # input
            ch = -1
            try:
                ch = stdscr.getch()
            except Exception:
                ch = -1

            if self.search_mode:
                if ch != -1:
                    if ch == 27:  # esc
                        self.cancel_search()
                        curses.curs_set(0)
                    elif ch in (10, 13, curses.KEY_ENTER):
                        self.apply_search()
                        curses.curs_set(0)
                    elif ch in (curses.KEY_BACKSPACE, 127, 8):
                        self.search_buf = self.search_buf[:-1]
                    elif 32 <= ch <= 126:
                        self.search_buf += chr(ch)
            else:
                if ch != -1:
                    if ch in (ord("q"), ord("Q")):
                        return
                    if ch in (ord("r"), ord("R")):
                        self.proc_dirty = True
                        self.toast("processes refreshed")
                    elif ch in (ord("s"), ord("S")):
                        self.cycle_sort()
                    elif ch in (ord("d"), ord("D")):
                        self.toggle_dynamic()
                    elif ch == ord("/"):
                        self.begin_search()
                    elif ch == curses.KEY_UP:
                        if self.selected > 0:
                            self.selected -= 1
                    elif ch == curses.KEY_DOWN:
                        if self.selected < max(0, len(self.view) - 1):
                            self.selected += 1
                    elif ch in (10, 13, curses.KEY_ENTER):
                        if self.view:
                            pid = self.view[self.selected]["pid"]
                            ok, err = self.kill_pid(pid, signal.SIGTERM)
                            self.toast("terminated" if ok else f"failed: {err}")
                            self.proc_dirty = True
                    elif ch in (ord("k"), ord("K")):
                        if self.view:
                            pid = self.view[self.selected]["pid"]
                            ok, err = self.kill_pid(pid, signal.SIGKILL)
                            self.toast("killed" if ok else f"failed: {err}")
                            self.proc_dirty = True
                    elif ch == curses.KEY_MOUSE:
                        try:
                            _, mx, my, _, bstate = curses.getmouse()
                        except Exception:
                            mx = my = bstate = 0
                        if bstate & getattr(curses, "BUTTON1_CLICKED", 0):
                            h, w = stdscr.getmaxyx()
                            lay = self.layout(h, w)
                            py, px, ph, pw = lay["proc"]
                            # inside rows start:
                            iy = py + 1
                            yy_hdr = iy + 2
                            rows_y = yy_hdr + 1
                            if self.view and (py <= my < py + ph) and (px <= mx < px + pw):
                                idx = self.view_scroll + (my - rows_y)
                                if 0 <= (my - rows_y) and idx < len(self.view):
                                    self.selected = idx

            # draw throttle
            if now - last_draw < (1.0 / float(UI_FPS)):
                time.sleep(0.002)
                continue
            last_draw = now

            h, w = stdscr.getmaxyx()
            stdscr.erase()

            if h < 26 or w < 110:
                safe_addnstr(stdscr, 0, 2, "Resize terminal (recommended >= 110x26).", w - 4,
                             curses.color_pair(2) | curses.A_BOLD)
                stdscr.refresh()
                continue

            self.draw_header(stdscr, w)

            lay = self.layout(h, w)
            perf_y, perf_x, perf_h, perf_w = lay["perf"]
            proc_y, proc_x, proc_h, proc_w = lay["proc"]
            search_y, search_x, search_h, search_w = lay["search"]

            self.draw_performance(stdscr, perf_y, perf_x, perf_h, perf_w)
            self.draw_processes(stdscr, proc_y, proc_x, proc_h, proc_w)

            if self.search_mode and search_h >= 3:
                self.draw_search_box(stdscr, search_y, search_x, search_h, search_w)
            else:
                try:
                    curses.curs_set(0)
                except Exception:
                    pass

            self.draw_footer(stdscr, h, w)
            stdscr.refresh()


def main():
    # let curses.wrapper restore terminal; also force-reset colors just in case
    try:
        curses.wrapper(TaskMan().run)
    finally:
        try:
            sys.stdout.write("\033[0m\033[39m\033[49m\033[?25h")
            sys.stdout.flush()
        except Exception:
            pass


if __name__ == "__main__":
    main()
