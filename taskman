#!/usr/bin/env python3
# taskman — dark, minimal “pro” task manager (black background)
# Python 3.8+ | Ubuntu 20/22/24
#
# Keys:
#   ↑↓ / PgUp PgDn    Select
#   Enter / K         End task (Terminate/Kill) — no PID typing
#   S                Sort (CPU / MEM)
#   /                Filter
#   R                Refresh now
#   Q                Exit

import os
import time
import curses
import shutil
import signal

REFRESH_SEC = 1.0
JUMP_ROWS = 12
SPARK_POINTS = 42

# -------------------- helpers --------------------

def clamp(n, lo, hi):
    return lo if n < lo else hi if n > hi else n

def read_text(path, default=""):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception:
        return default

def read_first_line(path, default=""):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.readline().strip()
    except Exception:
        return default

def ellipsize(s, w):
    if w <= 0:
        return ""
    if len(s) <= w:
        return s
    if w <= 1:
        return s[:w]
    return s[:w-1] + "…"

def human_bytes_dec(n):
    try:
        n = float(n)
    except Exception:
        return "0B"
    units = ["B", "KB", "MB", "GB", "TB"]
    u = 0
    while n >= 1000.0 and u < len(units) - 1:
        n /= 1000.0
        u += 1
    if u == 0:
        return f"{int(n)}{units[u]}"
    if units[u] in ("GB", "TB"):
        return f"{n:.2f}{units[u]}"
    return f"{n:.1f}{units[u]}"

def human_rate_dec(nps):
    return f"{human_bytes_dec(nps)}/s"

def meter(width, pct):
    # very clean “pill” meter on black bg
    pct = clamp(pct, 0.0, 100.0)
    fill = int(round((pct / 100.0) * width))
    fill = clamp(fill, 0, width)
    # use heavier blocks for filled, light dots for empty
    return "█" * fill + "·" * (width - fill)

SPARK_CHARS = "▁▂▃▄▅▆▇█"
def spark(pcts):
    if not pcts:
        return ""
    out = []
    for p in pcts[-SPARK_POINTS:]:
        p = clamp(p, 0.0, 100.0)
        i = int(round((p / 100.0) * (len(SPARK_CHARS) - 1)))
        out.append(SPARK_CHARS[clamp(i, 0, len(SPARK_CHARS)-1)])
    return "".join(out)

# -------------------- safe curses draw --------------------

def safe_addnstr(stdscr, y, x, s, n, attr=0):
    try:
        h, w = stdscr.getmaxyx()
        if y < 0 or y >= h or x < 0 or x >= w:
            return
        # don’t touch the last cell; some PTYs ERR
        maxn = max(0, min(n, w - x - 1))
        if maxn <= 0:
            return
        if attr:
            stdscr.attron(attr)
        stdscr.addnstr(y, x, s, maxn)
        if attr:
            stdscr.attroff(attr)
    except curses.error:
        return

def safe_fill(stdscr, y, x, n, attr=0):
    safe_addnstr(stdscr, y, x, " " * max(0, n), n, attr)

def safe_hline(stdscr, y, x, ch, n, attr=0):
    try:
        h, w = stdscr.getmaxyx()
        if y < 0 or y >= h or x < 0 or x >= w:
            return
        maxn = max(0, min(n, w - x - 1))
        if maxn <= 0:
            return
        if attr:
            stdscr.attron(attr)
        stdscr.hline(y, x, ch, maxn)
        if attr:
            stdscr.attroff(attr)
    except curses.error:
        return

# -------------------- system stats --------------------

def get_uptime_str():
    up = read_first_line("/proc/uptime", "0 0").split()
    try:
        sec = int(float(up[0]))
    except Exception:
        sec = 0
    days = sec // 86400
    sec %= 86400
    hh = sec // 3600
    sec %= 3600
    mm = sec // 60
    ss = sec % 60
    if days > 0:
        return f"{days}d {hh:02d}:{mm:02d}:{ss:02d}"
    return f"{hh:02d}:{mm:02d}:{ss:02d}"

def get_loadavg3():
    s = read_first_line("/proc/loadavg", "0 0 0 0/0 0").split()
    return (s[0], s[1], s[2]) if len(s) >= 3 else ("0", "0", "0")

def read_cpu_total_idle():
    line = read_first_line("/proc/stat", "")
    if not line.startswith("cpu "):
        return 0, 0
    parts = line.split()[1:]
    vals = []
    for x in parts:
        try:
            vals.append(int(x))
        except Exception:
            vals.append(0)
    total = sum(vals)
    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
    return total, idle

def read_meminfo_kb():
    out = {}
    for line in read_text("/proc/meminfo").splitlines():
        if ":" not in line:
            continue
        k, v = line.split(":", 1)
        v = v.strip().split()
        if not v:
            continue
        try:
            out[k] = int(v[0])
        except Exception:
            pass
    return out

def disk_usage_root():
    try:
        du = shutil.disk_usage("/")
        return du.total, du.used, du.free
    except Exception:
        return 0, 0, 0

def read_net_bytes_total():
    rx = 0
    tx = 0
    for line in read_text("/proc/net/dev").splitlines():
        if ":" not in line:
            continue
        iface, rest = line.split(":", 1)
        iface = iface.strip()
        if iface == "lo":
            continue
        cols = rest.split()
        if len(cols) < 16:
            continue
        try:
            rx += int(cols[0])
            tx += int(cols[8])
        except Exception:
            pass
    return rx, tx

# -------------------- processes --------------------

def list_pids():
    out = []
    try:
        for name in os.listdir("/proc"):
            if name.isdigit():
                out.append(int(name))
    except Exception:
        return []
    return out

def read_proc_stat_ticks(pid):
    s = read_text(f"/proc/{pid}/stat", "")
    if not s:
        return None
    r = s.rfind(")")
    if r == -1:
        return None
    after = s[r+2:].split()
    if len(after) < 13:
        return None
    try:
        ut = int(after[11])
        st = int(after[12])
        return ut + st
    except Exception:
        return None

def read_proc_rss_kb(pid):
    for line in read_text(f"/proc/{pid}/status").splitlines():
        if line.startswith("VmRSS:"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    return int(parts[1])
                except Exception:
                    return 0
    return 0

def read_proc_uid(pid):
    for line in read_text(f"/proc/{pid}/status").splitlines():
        if line.startswith("Uid:"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    return int(parts[1])
                except Exception:
                    return None
    return None

_UID_MAP = None
def uid_to_user(uid):
    global _UID_MAP
    if uid is None:
        return "?"
    if _UID_MAP is None:
        _UID_MAP = {}
        for line in read_text("/etc/passwd").splitlines():
            if ":" not in line:
                continue
            p = line.split(":")
            if len(p) >= 3:
                try:
                    _UID_MAP[int(p[2])] = p[0]
                except Exception:
                    pass
    return _UID_MAP.get(uid, str(uid))

def read_proc_cmd(pid):
    cmdline = read_text(f"/proc/{pid}/cmdline")
    if cmdline:
        s = cmdline.replace("\x00", " ").strip()
        if s:
            return s
    comm = read_first_line(f"/proc/{pid}/comm", "")
    return comm if comm else str(pid)

# -------------------- UI app --------------------

class TaskMan:
    def __init__(self):
        self.sort_mode = "CPU"   # CPU or MEM
        self.filter_text = ""
        self.selected = 0
        self.scroll = 0

        self.toast_msg = ""
        self.toast_until = 0.0

        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        self.cpu_pct = 0.0

        self.prev_rx = 0
        self.prev_tx = 0
        self.rx_rate = 0.0
        self.tx_rate = 0.0

        self.sysinfo = {
            "mem_total": 0, "mem_used": 0, "mem_pct": 0.0,
            "disk_total": 0, "disk_used": 0, "disk_pct": 0.0,
            "load": ("0", "0", "0"),
            "uptime": "00:00:00",
        }

        self.prev_proc_ticks = {}
        self.prev_cpu_total_for_procs = 0
        self.procs = []

        self.cpu_hist = []
        self.mem_hist = []
        self.disk_hist = []

    def init_colors(self, stdscr):
        curses.start_color()
        curses.use_default_colors()

        # Hard force black background (if terminal supports)
        try:
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK)    # base
            curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)     # accent
            curses.init_pair(3, curses.COLOR_MAGENTA, curses.COLOR_BLACK)  # accent 2
            curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK)   # warn
            curses.init_pair(5, curses.COLOR_RED, curses.COLOR_BLACK)      # hot
            curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_WHITE)    # selected
            curses.init_pair(7, curses.COLOR_WHITE, curses.COLOR_BLACK)    # normal
        except curses.error:
            pass

        stdscr.bkgd(" ", curses.color_pair(1))

    def toast(self, msg, secs=2.0):
        self.toast_msg = msg
        self.toast_until = time.monotonic() + secs

    def refresh_system(self, dt):
        total, idle = read_cpu_total_idle()
        if self.prev_cpu_total:
            d_total = max(1, total - self.prev_cpu_total)
            d_idle = max(0, idle - self.prev_cpu_idle)
            self.cpu_pct = clamp((1.0 - (d_idle / d_total)) * 100.0, 0.0, 100.0)
        self.prev_cpu_total, self.prev_cpu_idle = total, idle

        mi = read_meminfo_kb()
        mem_total_kb = mi.get("MemTotal", 0)
        mem_avail_kb = mi.get("MemAvailable", 0)
        mem_used_kb = max(0, mem_total_kb - mem_avail_kb)
        mem_pct = (mem_used_kb / mem_total_kb * 100.0) if mem_total_kb else 0.0

        d_total, d_used, _ = disk_usage_root()
        d_pct = (d_used / d_total * 100.0) if d_total else 0.0

        rx, tx = read_net_bytes_total()
        if self.prev_rx:
            self.rx_rate = max(0.0, (rx - self.prev_rx) / dt)
        if self.prev_tx:
            self.tx_rate = max(0.0, (tx - self.prev_tx) / dt)
        self.prev_rx, self.prev_tx = rx, tx

        self.sysinfo = {
            "mem_total": mem_total_kb * 1024,
            "mem_used": mem_used_kb * 1024,
            "mem_pct": mem_pct,
            "disk_total": d_total,
            "disk_used": d_used,
            "disk_pct": d_pct,
            "load": get_loadavg3(),
            "uptime": get_uptime_str(),
        }

        # history (sparks)
        self.cpu_hist.append(self.cpu_pct)
        self.mem_hist.append(mem_pct)
        self.disk_hist.append(d_pct)
        self.cpu_hist = self.cpu_hist[-SPARK_POINTS:]
        self.mem_hist = self.mem_hist[-SPARK_POINTS:]
        self.disk_hist = self.disk_hist[-SPARK_POINTS:]

    def refresh_processes(self):
        pids = list_pids()
        cpu_total, _ = read_cpu_total_idle()
        total_delta = max(1, cpu_total - self.prev_cpu_total_for_procs) if self.prev_cpu_total_for_procs else 1
        self.prev_cpu_total_for_procs = cpu_total

        out = []
        ftxt = self.filter_text.lower().strip()

        for pid in pids:
            ticks = read_proc_stat_ticks(pid)
            if ticks is None:
                continue
            prev = self.prev_proc_ticks.get(pid, ticks)
            self.prev_proc_ticks[pid] = ticks
            proc_delta = max(0, ticks - prev)
            cpu_pct = (proc_delta / total_delta) * 100.0

            rss_kb = read_proc_rss_kb(pid)
            mem_bytes = rss_kb * 1024

            uid = read_proc_uid(pid)
            user = uid_to_user(uid)
            cmd = read_proc_cmd(pid)

            if ftxt:
                if ftxt not in cmd.lower() and ftxt not in user.lower() and ftxt not in str(pid):
                    continue

            out.append({"pid": pid, "user": user, "cpu": cpu_pct, "mem_bytes": mem_bytes, "cmd": cmd})

        if self.sort_mode == "MEM":
            out.sort(key=lambda x: (x["mem_bytes"], x["cpu"]), reverse=True)
        else:
            out.sort(key=lambda x: (x["cpu"], x["mem_bytes"]), reverse=True)

        if self.selected >= len(out):
            self.selected = max(0, len(out) - 1)

        self.procs = out

    # -------------- dialogs --------------

    def dialog_kill(self, stdscr, pid):
        h, w = stdscr.getmaxyx()
        dw = min(64, max(36, w - 10))
        dh = 7
        x = max(0, (w - dw) // 2)
        y = max(0, (h - dh) // 2)

        opts = [("Terminate", signal.SIGTERM), ("Kill", signal.SIGKILL), ("Cancel", None)]
        sel = 0

        stdscr.nodelay(False)
        while True:
            # dim panel on black
            for yy in range(dh):
                safe_fill(stdscr, y + yy, x, dw, curses.color_pair(1))

            safe_addnstr(stdscr, y, x, " " * dw, dw, curses.color_pair(1) | curses.A_BOLD)
            safe_addnstr(stdscr, y, x + 2, ellipsize(f"End task • PID {pid}", dw - 4), dw - 4,
                         curses.color_pair(2) | curses.A_BOLD)
            safe_addnstr(stdscr, y + 2, x + 2, "Choose:", dw - 4, curses.color_pair(7))

            for i, (label, _) in enumerate(opts):
                yy = y + 4 + i
                if i == sel:
                    safe_fill(stdscr, yy, x + 2, dw - 4, curses.color_pair(6))
                    safe_addnstr(stdscr, yy, x + 3, label, dw - 6, curses.color_pair(6) | curses.A_BOLD)
                else:
                    safe_addnstr(stdscr, yy, x + 3, label, dw - 6, curses.color_pair(7))

            safe_addnstr(stdscr, y + dh - 1, x + 2, "Enter=Select  Esc=Back", dw - 4, curses.color_pair(3))
            stdscr.refresh()

            ch = stdscr.getch()
            if ch in (27, ord("q"), ord("Q")):
                stdscr.nodelay(True)
                return None
            if ch == curses.KEY_UP:
                sel = max(0, sel - 1)
            elif ch == curses.KEY_DOWN:
                sel = min(len(opts) - 1, sel + 1)
            elif ch in (curses.KEY_ENTER, 10, 13):
                stdscr.nodelay(True)
                return opts[sel][1]

    def dialog_filter(self, stdscr):
        h, w = stdscr.getmaxyx()
        dw = min(70, max(40, w - 10))
        dh = 6
        x = max(0, (w - dw) // 2)
        y = max(0, (h - dh) // 2)
        s = self.filter_text or ""

        curses.curs_set(1)
        stdscr.nodelay(False)
        while True:
            for yy in range(dh):
                safe_fill(stdscr, y + yy, x, dw, curses.color_pair(1))

            safe_addnstr(stdscr, y, x + 2, "Filter", dw - 4, curses.color_pair(2) | curses.A_BOLD)
            safe_addnstr(stdscr, y + 2, x + 2, "Type → Enter (empty clears) • Esc cancel", dw - 4, curses.color_pair(3))
            safe_addnstr(stdscr, y + 4, x + 2, "> " + ellipsize(s, dw - 4), dw - 4, curses.color_pair(7))

            try:
                stdscr.move(y + 4, min(x + 4 + len(s), x + dw - 2))
            except curses.error:
                pass
            stdscr.refresh()

            ch = stdscr.getch()
            if ch == 27:
                stdscr.nodelay(True)
                curses.curs_set(0)
                return None
            if ch in (10, 13):
                stdscr.nodelay(True)
                curses.curs_set(0)
                return s.strip()
            if ch in (curses.KEY_BACKSPACE, 127, 8):
                s = s[:-1]
            elif 32 <= ch <= 126:
                s += chr(ch)

    def kill_pid(self, pid, sig):
        try:
            os.kill(pid, sig)
            return True, ""
        except PermissionError:
            return False, "permission denied"
        except ProcessLookupError:
            return False, "no such process"
        except Exception as e:
            return False, str(e)

    # -------------- drawing --------------

    def color_for_pct(self, pct):
        if pct >= 90:
            return curses.color_pair(5)  # red
        if pct >= 70:
            return curses.color_pair(4)  # yellow
        return curses.color_pair(2)      # cyan

    def draw_top(self, stdscr, w):
        load1, load5, load15 = self.sysinfo["load"]
        up = self.sysinfo["uptime"]

        # top info line (no blocks/bars)
        left = "taskman"
        mid = f"cpu {self.cpu_pct:4.1f}%"
        right = f"load {load1} {load5} {load15} • up {up}"

        safe_fill(stdscr, 0, 0, w, curses.color_pair(1))
        safe_addnstr(stdscr, 0, 2, left, w - 4, curses.color_pair(7) | curses.A_BOLD)
        safe_addnstr(stdscr, 0, max(2, w // 2 - len(mid) // 2), mid, len(mid), curses.color_pair(3))
        safe_addnstr(stdscr, 0, max(2, w - len(right) - 3), right, len(right), curses.color_pair(3))

        # toast (small, quiet)
        if self.toast_msg and time.monotonic() < self.toast_until:
            safe_addnstr(stdscr, 1, 2, ellipsize(self.toast_msg, w - 4), w - 4, curses.color_pair(4))
        else:
            self.toast_msg = ""
            safe_fill(stdscr, 1, 0, w, curses.color_pair(1))

    def draw_dashboard(self, stdscr, y, x, w):
        # Minimal “studio” dashboard
        cpu = self.cpu_pct
        mem_pct = self.sysinfo["mem_pct"]
        disk_pct = self.sysinfo["disk_pct"]

        mem_used = self.sysinfo["mem_used"]
        mem_total = self.sysinfo["mem_total"]
        d_used = self.sysinfo["disk_used"]
        d_total = self.sysinfo["disk_total"]

        # lines are: label | spark | meter | value
        spark_w = min(SPARK_POINTS, max(16, int(w * 0.22)))
        meter_w = max(18, w - (8 + spark_w + 2 + 22))
        if meter_w < 18:
            meter_w = 18

        def draw_line(row, label, pct, hist, value_left, value_right):
            lab = label.ljust(6)
            sp = spark(hist)[-spark_w:].rjust(spark_w)
            m = meter(meter_w, pct)
            col = self.color_for_pct(pct)

            safe_addnstr(stdscr, row, x, lab, 6, curses.color_pair(7) | curses.A_BOLD)
            safe_addnstr(stdscr, row, x + 7, sp, spark_w, curses.color_pair(3))
            safe_addnstr(stdscr, row, x + 7 + spark_w + 2, m, meter_w, col)
            text = f"{value_left}  {value_right}".strip()
            safe_addnstr(stdscr, row, x + 7 + spark_w + 2 + meter_w + 2, ellipsize(text, 22), 22, curses.color_pair(7))

        draw_line(y + 0, "CPU", cpu, self.cpu_hist, f"{cpu:4.1f}%", "")
        draw_line(y + 1, "MEM", mem_pct, self.mem_hist, f"{human_bytes_dec(mem_used)} / {human_bytes_dec(mem_total)}", f"{mem_pct:4.1f}%")
        draw_line(y + 2, "DSK", disk_pct, self.disk_hist, f"{human_bytes_dec(d_used)} / {human_bytes_dec(d_total)}", f"{disk_pct:4.1f}%")

        # network (quiet)
        net = f"NET  ↓ {human_rate_dec(self.rx_rate)}   ↑ {human_rate_dec(self.tx_rate)}"
        safe_addnstr(stdscr, y + 3, x, ellipsize(net, w), w, curses.color_pair(3))

        # divider
        safe_hline(stdscr, y + 4, x, ord("─"), w, curses.color_pair(1))

    def draw_table(self, stdscr, y, x, h, w):
        # columns: NAME | CPU | MEM | PID | USER
        col_cpu = 7
        col_mem = 10
        col_pid = 8
        col_user = 10
        col_name = w - (col_cpu + col_mem + col_pid + col_user + 4)
        if col_name < 18:
            col_name = 18

        # header
        hdr_attr = curses.color_pair(3) | curses.A_BOLD
        safe_addnstr(stdscr, y, x, "NAME", col_name, hdr_attr)
        safe_addnstr(stdscr, y, x + col_name + 1, "CPU", col_cpu, hdr_attr)
        safe_addnstr(stdscr, y, x + col_name + 1 + col_cpu + 1, "MEM", col_mem, hdr_attr)
        safe_addnstr(stdscr, y, x + col_name + 1 + col_cpu + 1 + col_mem + 1, "PID", col_pid, hdr_attr)
        safe_addnstr(stdscr, y, x + col_name + 1 + col_cpu + 1 + col_mem + 1 + col_pid + 1, "USER", col_user, hdr_attr)

        safe_hline(stdscr, y + 1, x, ord("─"), w, curses.color_pair(1))

        rows_y = y + 2
        rows_avail = max(1, h - 4)
        n = len(self.procs)

        if self.selected < self.scroll:
            self.scroll = self.selected
        if self.selected >= self.scroll + rows_avail:
            self.scroll = self.selected - rows_avail + 1
        self.scroll = clamp(self.scroll, 0, max(0, n - rows_avail))

        for i in range(rows_avail):
            idx = self.scroll + i
            yy = rows_y + i
            if idx >= n:
                safe_fill(stdscr, yy, x, w, curses.color_pair(1))
                continue

            p = self.procs[idx]
            cmd = ellipsize(p["cmd"], col_name)
            cpu = p["cpu"]
            mem = human_bytes_dec(p["mem_bytes"])
            pid = str(p["pid"])
            user = ellipsize(p["user"], col_user)

            selected = (idx == self.selected)
            if selected:
                row_attr = curses.color_pair(6) | curses.A_BOLD
                safe_fill(stdscr, yy, x, w, row_attr)
            else:
                row_attr = curses.color_pair(7)

            safe_addnstr(stdscr, yy, x, cmd, col_name, row_attr)
            cpu_txt = f"{cpu:5.1f}%"
            cpu_attr = row_attr if selected else self.color_for_pct(cpu)
            safe_addnstr(stdscr, yy, x + col_name + 1, cpu_txt, col_cpu, cpu_attr)
            safe_addnstr(stdscr, yy, x + col_name + 1 + col_cpu + 1, ellipsize(mem, col_mem), col_mem, row_attr)
            safe_addnstr(stdscr, yy, x + col_name + 1 + col_cpu + 1 + col_mem + 1, ellipsize(pid, col_pid), col_pid, row_attr)
            safe_addnstr(stdscr, yy, x + col_name + 1 + col_cpu + 1 + col_mem + 1 + col_pid + 1, user, col_user, row_attr)

        # footer info
        footer = f"{n} procs  •  sort {self.sort_mode.lower()}  •  filter {(self.filter_text or '—')}"
        safe_addnstr(stdscr, y + h - 2, x, ellipsize(footer, w), w, curses.color_pair(3))

    def draw_bottom(self, stdscr, h, w):
        # bottom command line (no bright bar)
        cmd = "↑↓ select  pgup/pgdn jump  enter/k end  s sort  / filter  r refresh  q exit"
        safe_hline(stdscr, h - 2, 0, ord("─"), w, curses.color_pair(1))
        safe_addnstr(stdscr, h - 1, 2, ellipsize(cmd, w - 4), w - 4, curses.color_pair(3))

    # -------------- loop --------------

    def run(self, stdscr):
        curses.curs_set(0)
        stdscr.nodelay(True)
        stdscr.keypad(True)
        self.init_colors(stdscr)

        self.prev_cpu_total, self.prev_cpu_idle = read_cpu_total_idle()
        self.prev_rx, self.prev_tx = read_net_bytes_total()

        last_refresh = time.monotonic()
        dt_last = REFRESH_SEC

        self.refresh_system(REFRESH_SEC)
        self.refresh_processes()
        need_redraw = True

        while True:
            now = time.monotonic()

            if now - last_refresh >= REFRESH_SEC:
                dt = now - last_refresh
                last_refresh = now
                dt_last = max(0.35, dt)
                self.refresh_system(dt_last)
                self.refresh_processes()
                need_redraw = True

            try:
                ch = stdscr.getch()
            except Exception:
                ch = -1

            if ch != -1:
                if ch in (ord("q"), ord("Q")):
                    return

                elif ch in (ord("r"), ord("R")):
                    self.refresh_system(max(0.35, dt_last))
                    self.refresh_processes()
                    self.toast("refreshed", 0.9)
                    need_redraw = True

                elif ch in (ord("s"), ord("S")):
                    self.sort_mode = "MEM" if self.sort_mode == "CPU" else "CPU"
                    self.refresh_processes()
                    self.toast(f"sort: {self.sort_mode.lower()}", 0.9)
                    need_redraw = True

                elif ch == ord("/"):
                    s = self.dialog_filter(stdscr)
                    if s is not None:
                        self.filter_text = s
                        self.selected = 0
                        self.scroll = 0
                        self.refresh_processes()
                        self.toast("filter set" if s else "filter cleared", 1.2)
                        need_redraw = True

                elif ch == curses.KEY_UP:
                    if self.selected > 0:
                        self.selected -= 1
                        need_redraw = True

                elif ch == curses.KEY_DOWN:
                    if self.selected < max(0, len(self.procs) - 1):
                        self.selected += 1
                        need_redraw = True

                elif ch == curses.KEY_PPAGE:
                    self.selected = max(0, self.selected - JUMP_ROWS)
                    need_redraw = True

                elif ch == curses.KEY_NPAGE:
                    self.selected = min(max(0, len(self.procs) - 1), self.selected + JUMP_ROWS)
                    need_redraw = True

                elif ch in (ord("k"), ord("K"), curses.KEY_ENTER, 10, 13):
                    if self.procs:
                        pid = self.procs[self.selected]["pid"]
                        sig = self.dialog_kill(stdscr, pid)
                        if sig is not None:
                            ok, err = self.kill_pid(pid, sig)
                            if ok:
                                self.toast("signal sent", 1.0)
                            else:
                                self.toast(f"failed: {err}", 1.6)
                            self.refresh_processes()
                        need_redraw = True

            toast_visible = self.toast_msg and (time.monotonic() < self.toast_until)
            if need_redraw or toast_visible:
                h, w = stdscr.getmaxyx()
                stdscr.erase()

                if h < 18 or w < 86:
                    msg = "Resize terminal (recommended >= 86x18)."
                    safe_addnstr(stdscr, 0, 2, msg, w - 4, curses.color_pair(7))
                    stdscr.refresh()
                    time.sleep(0.06)
                    continue

                self.draw_top(stdscr, w)

                pad_x = 2
                dash_w = w - pad_x * 2
                self.draw_dashboard(stdscr, 2, pad_x, dash_w)

                table_y = 2 + 5  # dashboard height (5 lines)
                table_h = h - table_y - 2  # bottom area (2 lines)
                self.draw_table(stdscr, table_y, pad_x, table_h, dash_w)

                self.draw_bottom(stdscr, h, w)

                stdscr.refresh()
                need_redraw = False

            time.sleep(0.03)

def main():
    curses.wrapper(TaskMan().run)

if __name__ == "__main__":
    main()
