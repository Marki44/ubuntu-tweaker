#!/usr/bin/env python3
# taskman — “Neo” Task Manager (different look + low CPU)
# Ubuntu 20/22/24 | Python 3.8+ | Arrow-select + End Task (no PID typing)
#
# Goals:
# - Different visual style (no big ASCII boxes everywhere)
# - Calm colors (no default terminal green)
# - Low CPU: refresh once/second, redraw only on input/tick
# - Summary shows Used/Total + % + bar for Memory/Disk
#
# Keys:
#   Tab  switch tab (Processes / Performance)
#   ↑↓   move selection
#   PgUp/PgDn scroll faster
#   Enter open “End task” dialog
#   K    open “End task” dialog
#   S    toggle sort (CPU / MEM)
#   /    filter
#   Q    quit

import os
import time
import curses
import shutil
import signal

REFRESH_SEC = 1.0
MAX_VISIBLE_IO = 22

# -------------------- utilities --------------------

def clamp(n, lo, hi):
    return lo if n < lo else hi if n > hi else n

def read_text(path, default=""):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()
    except Exception:
        return default

def read_first_line(path, default=""):
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.readline().strip()
    except Exception:
        return default

def human_bytes(n):
    try:
        n = float(n)
    except Exception:
        return "0B"
    units = ["B", "KiB", "MiB", "GiB", "TiB"]
    u = 0
    while n >= 1024 and u < len(units) - 1:
        n /= 1024.0
        u += 1
    if u == 0:
        return f"{int(n)}{units[u]}"
    return f"{n:.1f}{units[u]}"

def human_rate(nps):
    return f"{human_bytes(nps)}/s"

def ellipsize(s, w):
    if w <= 0:
        return ""
    if len(s) <= w:
        return s
    if w <= 1:
        return s[:w]
    return s[: w - 1] + "…"

def bar(width, pct):
    pct = clamp(pct, 0.0, 100.0)
    fill = int(round((pct / 100.0) * width))
    fill = clamp(fill, 0, width)
    return "█" * fill + " " * (width - fill)

# -------------------- system stats --------------------

def get_loadavg3():
    s = read_first_line("/proc/loadavg", "0 0 0 0/0 0")
    p = s.split()
    return (p[0], p[1], p[2]) if len(p) >= 3 else ("0", "0", "0")

def read_cpu_total_idle():
    line = read_first_line("/proc/stat", "")
    if not line.startswith("cpu "):
        return 0, 0
    parts = line.split()
    vals = []
    for x in parts[1:]:
        try:
            vals.append(int(x))
        except Exception:
            vals.append(0)
    total = sum(vals)
    idle = vals[3] + (vals[4] if len(vals) > 4 else 0)
    return total, idle

def read_meminfo_kb():
    out = {}
    for line in read_text("/proc/meminfo").splitlines():
        if ":" not in line:
            continue
        k, v = line.split(":", 1)
        v = v.strip().split()
        if not v:
            continue
        try:
            out[k] = int(v[0])
        except Exception:
            pass
    return out

def disk_usage_root():
    try:
        du = shutil.disk_usage("/")
        return du.total, du.used, du.free
    except Exception:
        return 0, 0, 0

def read_net_bytes_total():
    rx = 0
    tx = 0
    for line in read_text("/proc/net/dev").splitlines():
        if ":" not in line:
            continue
        iface, rest = line.split(":", 1)
        iface = iface.strip()
        if iface == "lo":
            continue
        cols = rest.split()
        if len(cols) < 16:
            continue
        try:
            rx += int(cols[0])
            tx += int(cols[8])
        except Exception:
            pass
    return rx, tx

# -------------------- processes --------------------

def list_pids():
    out = []
    try:
        for name in os.listdir("/proc"):
            if name.isdigit():
                out.append(int(name))
    except Exception:
        return []
    return out

def read_proc_stat_ticks(pid):
    s = read_text(f"/proc/{pid}/stat", "")
    if not s:
        return None
    r = s.rfind(")")
    if r == -1:
        return None
    after = s[r + 2 :].split()
    if len(after) < 13:
        return None
    try:
        ut = int(after[11])
        st = int(after[12])
        return ut + st
    except Exception:
        return None

def read_proc_rss_kb(pid):
    for line in read_text(f"/proc/{pid}/status").splitlines():
        if line.startswith("VmRSS:"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    return int(parts[1])
                except Exception:
                    return 0
    return 0

def read_proc_uid(pid):
    for line in read_text(f"/proc/{pid}/status").splitlines():
        if line.startswith("Uid:"):
            parts = line.split()
            if len(parts) >= 2:
                try:
                    return int(parts[1])
                except Exception:
                    return None
            return None
    return None

_UID_MAP = None
def uid_to_user(uid):
    global _UID_MAP
    if uid is None:
        return "?"
    if _UID_MAP is None:
        _UID_MAP = {}
        for line in read_text("/etc/passwd").splitlines():
            if ":" not in line:
                continue
            p = line.split(":")
            if len(p) < 3:
                continue
            try:
                _UID_MAP[int(p[2])] = p[0]
            except Exception:
                pass
    return _UID_MAP.get(uid, str(uid))

def read_proc_cmd(pid):
    cmdline = read_text(f"/proc/{pid}/cmdline")
    if cmdline:
        s = cmdline.replace("\x00", " ").strip()
        if s:
            return s
    comm = read_first_line(f"/proc/{pid}/comm", "")
    return comm if comm else str(pid)

def read_proc_io_bytes(pid):
    rb = 0
    wb = 0
    txt = read_text(f"/proc/{pid}/io", "")
    if not txt:
        return 0, 0
    for line in txt.splitlines():
        if line.startswith("read_bytes:"):
            try:
                rb = int(line.split(":", 1)[1].strip())
            except Exception:
                rb = 0
        elif line.startswith("write_bytes:"):
            try:
                wb = int(line.split(":", 1)[1].strip())
            except Exception:
                wb = 0
    return rb, wb

# -------------------- UI --------------------

TAB_PROCESSES = 0
TAB_PERF      = 1

class TaskManNeo:
    def __init__(self):
        self.tab = TAB_PROCESSES
        self.sort_mode = "CPU"   # CPU / MEM
        self.filter_text = ""
        self.selected = 0
        self.scroll = 0

        self.toast_msg = ""
        self.toast_until = 0.0

        # system deltas
        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        self.cpu_pct = 0.0
        self.prev_rx = 0
        self.prev_tx = 0
        self.rx_rate = 0.0
        self.tx_rate = 0.0

        # proc deltas
        self.prev_proc_ticks = {}  # pid -> ticks
        self.prev_cpu_total_for_procs = 0
        self.prev_proc_io = {}     # pid -> (rb, wb)
        self.io_bps_cache = {}     # pid -> io_bps for visible rows

        self.sysinfo = {
            "mem_total": 0, "mem_used": 0, "mem_pct": 0.0,
            "disk_total": 0, "disk_used": 0, "disk_pct": 0.0,
            "load": ("0", "0", "0"),
        }
        self.procs = []

    # ---- colors ----

    def init_colors(self):
        curses.start_color()
        curses.use_default_colors()

        # If terminal supports it, we use a dark-ish header bar look by pairing bg colors.
        # If not supported, curses will still render with -1 background.
        try:
            curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)   # header bar
            curses.init_pair(2, curses.COLOR_CYAN, -1)                   # accents
            curses.init_pair(3, curses.COLOR_MAGENTA, -1)                # accents 2
            curses.init_pair(4, curses.COLOR_YELLOW, -1)                 # warn
            curses.init_pair(5, curses.COLOR_RED, -1)                    # hot
            curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_CYAN)   # selection row
            curses.init_pair(7, curses.COLOR_WHITE, -1)                  # normal
            curses.init_pair(8, curses.COLOR_BLUE, -1)                   # subtle
        except Exception:
            pass

    def toast(self, msg, secs=2.0):
        self.toast_msg = msg
        self.toast_until = time.monotonic() + secs

    # ---- refresh ----

    def calc_system(self, dt):
        total, idle = read_cpu_total_idle()
        if self.prev_cpu_total:
            d_total = max(1, total - self.prev_cpu_total)
            d_idle = max(0, idle - self.prev_cpu_idle)
            self.cpu_pct = clamp((1.0 - (d_idle / d_total)) * 100.0, 0.0, 100.0)
        self.prev_cpu_total, self.prev_cpu_idle = total, idle

        mi = read_meminfo_kb()
        mem_total_kb = mi.get("MemTotal", 0)
        mem_avail_kb = mi.get("MemAvailable", 0)
        mem_used_kb = max(0, mem_total_kb - mem_avail_kb)
        mem_pct = (mem_used_kb / mem_total_kb * 100.0) if mem_total_kb else 0.0

        d_total, d_used, _ = disk_usage_root()
        d_pct = (d_used / d_total * 100.0) if d_total else 0.0

        rx, tx = read_net_bytes_total()
        if self.prev_rx:
            self.rx_rate = max(0.0, (rx - self.prev_rx) / dt)
        if self.prev_tx:
            self.tx_rate = max(0.0, (tx - self.prev_tx) / dt)
        self.prev_rx, self.prev_tx = rx, tx

        self.sysinfo = {
            "mem_total": mem_total_kb * 1024,
            "mem_used": mem_used_kb * 1024,
            "mem_pct": mem_pct,
            "disk_total": d_total,
            "disk_used": d_used,
            "disk_pct": d_pct,
            "load": get_loadavg3(),
        }

    def build_processes(self, dt):
        pids = list_pids()
        cpu_total, _ = read_cpu_total_idle()
        total_delta = max(1, cpu_total - self.prev_cpu_total_for_procs) if self.prev_cpu_total_for_procs else 1
        self.prev_cpu_total_for_procs = cpu_total

        procs = []
        for pid in pids:
            ticks = read_proc_stat_ticks(pid)
            if ticks is None:
                continue

            prev_ticks = self.prev_proc_ticks.get(pid, ticks)
            self.prev_proc_ticks[pid] = ticks
            proc_delta = max(0, ticks - prev_ticks)
            cpu_pct = (proc_delta / total_delta) * 100.0

            rss_kb = read_proc_rss_kb(pid)
            mem_mb = rss_kb / 1024.0

            uid = read_proc_uid(pid)
            user = uid_to_user(uid)
            cmd = read_proc_cmd(pid)

            if self.filter_text:
                f = self.filter_text.lower()
                if f not in cmd.lower() and f not in user.lower() and f not in str(pid):
                    continue

            procs.append({
                "pid": pid,
                "user": user,
                "cpu": cpu_pct,
                "mem_mb": mem_mb,
                "cmd": cmd,
            })

        if self.sort_mode == "MEM":
            procs.sort(key=lambda x: (x["mem_mb"], x["cpu"]), reverse=True)
        else:
            procs.sort(key=lambda x: (x["cpu"], x["mem_mb"]), reverse=True)

        self.procs = procs
        self.io_bps_cache = {}

        if self.selected >= len(self.procs):
            self.selected = max(0, len(self.procs) - 1)

    def update_visible_io(self, visible_pids, dt):
        if dt <= 0:
            dt = 1.0
        for pid in visible_pids:
            rb, wb = read_proc_io_bytes(pid)
            prb, pwb = self.prev_proc_io.get(pid, (rb, wb))
            self.prev_proc_io[pid] = (rb, wb)
            io_bps = (max(0, rb - prb) + max(0, wb - pwb)) / dt
            self.io_bps_cache[pid] = io_bps

    # ---- dialogs ----

    def dialog_kill(self, stdscr, pid):
        opts = [("Terminate (SIGTERM)", signal.SIGTERM),
                ("Kill (SIGKILL)", signal.SIGKILL),
                ("Cancel", None)]
        sel = 0
        h, w = stdscr.getmaxyx()
        dh = 8
        dw = min(62, w - 6)
        y = (h - dh) // 2
        x = (w - dw) // 2

        while True:
            # simple panel
            for yy in range(dh):
                stdscr.addnstr(y + yy, x, " " * dw, dw)

            title = f" End task • PID {pid} "
            stdscr.attron(curses.color_pair(1) | curses.A_BOLD)
            stdscr.addnstr(y, x, " " * dw, dw)
            stdscr.addnstr(y, x + 2, ellipsize(title, dw - 4), dw - 4)
            stdscr.attroff(curses.color_pair(1) | curses.A_BOLD)

            stdscr.attron(curses.color_pair(7))
            stdscr.addnstr(y + 2, x + 2, "Choose:", dw - 4)
            stdscr.attroff(curses.color_pair(7))

            for i, (label, _) in enumerate(opts):
                yy = y + 4 + i
                if i == sel:
                    stdscr.attron(curses.color_pair(6) | curses.A_BOLD)
                    stdscr.addnstr(yy, x + 2, ellipsize("▶ " + label, dw - 4), dw - 4)
                    stdscr.attroff(curses.color_pair(6) | curses.A_BOLD)
                else:
                    stdscr.attron(curses.color_pair(7))
                    stdscr.addnstr(yy, x + 2, ellipsize("  " + label, dw - 4), dw - 4)
                    stdscr.attroff(curses.color_pair(7))

            stdscr.attron(curses.color_pair(8))
            stdscr.addnstr(y + dh - 1, x + 2, "Enter=Select   Esc=Cancel", dw - 4)
            stdscr.attroff(curses.color_pair(8))
            stdscr.refresh()

            ch = stdscr.getch()
            if ch in (27, ord("q"), ord("Q")):
                return None
            if ch in (curses.KEY_UP, ord("k")):
                sel = max(0, sel - 1)
            elif ch in (curses.KEY_DOWN, ord("j")):
                sel = min(len(opts) - 1, sel + 1)
            elif ch in (curses.KEY_ENTER, 10, 13):
                return opts[sel][1]

    def dialog_filter(self, stdscr):
        h, w = stdscr.getmaxyx()
        dh = 6
        dw = min(70, w - 6)
        y = (h - dh) // 2
        x = (w - dw) // 2
        s = self.filter_text or ""

        curses.curs_set(1)
        stdscr.nodelay(False)

        while True:
            for yy in range(dh):
                stdscr.addnstr(y + yy, x, " " * dw, dw)

            stdscr.attron(curses.color_pair(1) | curses.A_BOLD)
            stdscr.addnstr(y, x, " " * dw, dw)
            stdscr.addnstr(y, x + 2, " Filter ", dw - 4)
            stdscr.attroff(curses.color_pair(1) | curses.A_BOLD)

            stdscr.attron(curses.color_pair(8))
            stdscr.addnstr(y + 2, x + 2, "Type text then Enter. Esc cancels. Empty clears.", dw - 4)
            stdscr.attroff(curses.color_pair(8))

            stdscr.attron(curses.color_pair(7))
            stdscr.addnstr(y + 4, x + 2, ">", 1)
            stdscr.addnstr(y + 4, x + 4, ellipsize(s, dw - 6), dw - 6)
            stdscr.attroff(curses.color_pair(7))

            stdscr.move(y + 4, min(x + 4 + len(s), x + dw - 2))
            stdscr.refresh()

            ch = stdscr.getch()
            if ch == 27:
                stdscr.nodelay(True)
                curses.curs_set(0)
                return None
            if ch in (10, 13):
                stdscr.nodelay(True)
                curses.curs_set(0)
                return s.strip()
            if ch in (curses.KEY_BACKSPACE, 127, 8):
                s = s[:-1]
            elif 32 <= ch <= 126:
                s += chr(ch)

    def kill_pid(self, pid, sig):
        try:
            os.kill(pid, sig)
            return True, ""
        except PermissionError:
            return False, "permission denied"
        except ProcessLookupError:
            return False, "no such process"
        except Exception as e:
            return False, str(e)

    # ---- drawing ----

    def draw_header(self, stdscr, w):
        left = " taskman "
        tab1 = " Processes " if self.tab == TAB_PROCESSES else "  Processes  "
        tab2 = " Performance " if self.tab == TAB_PERF else "  Performance  "
        right = "Tab • Enter/K • S sort • / filter • Q quit"

        stdscr.attron(curses.color_pair(1) | curses.A_BOLD)
        stdscr.addnstr(0, 0, " " * w, w)
        stdscr.addnstr(0, 1, left, w - 2)

        # tabs
        x = 10
        if x < w - 1:
            if self.tab == TAB_PROCESSES:
                stdscr.attron(curses.A_REVERSE)
            stdscr.addnstr(0, x, tab1, w - x - 1)
            if self.tab == TAB_PROCESSES:
                stdscr.attroff(curses.A_REVERSE)
        x += len(tab1) + 1
        if x < w - 1:
            if self.tab == TAB_PERF:
                stdscr.attron(curses.A_REVERSE)
            stdscr.addnstr(0, x, tab2, w - x - 1)
            if self.tab == TAB_PERF:
                stdscr.attroff(curses.A_REVERSE)

        # right help
        if len(right) + 2 < w:
            stdscr.addnstr(0, w - len(right) - 2, right, len(right))

        stdscr.attroff(curses.color_pair(1) | curses.A_BOLD)

        # toast line (1)
        now = time.monotonic()
        if self.toast_msg and now < self.toast_until:
            stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            stdscr.addnstr(1, 2, ellipsize(self.toast_msg, w - 4), w - 4)
            stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        else:
            self.toast_msg = ""
            stdscr.attron(curses.color_pair(8))
            stdscr.addnstr(1, 2, " " * (w - 4), w - 4)
            stdscr.attroff(curses.color_pair(8))

    def draw_sidebar(self, stdscr, y, h, w):
        # minimal sidebar: no boxes
        stdscr.attron(curses.color_pair(8))
        for i in range(h):
            stdscr.addnstr(y + i, 0, " " * w, w)
        stdscr.attroff(curses.color_pair(8))

        items = [
            ("Overview", None),
            ("Processes", TAB_PROCESSES),
            ("Performance", TAB_PERF),
            ("", None),
            ("Exit", "Q"),
        ]

        yy = y + 1
        for label, val in items:
            if yy >= y + h - 1:
                break
            if label == "":
                yy += 1
                continue

            if val == "Q":
                stdscr.attron(curses.color_pair(3))
                stdscr.addnstr(yy, 2, "⏻  Exit (Q)", w - 4)
                stdscr.attroff(curses.color_pair(3))
            elif val is None:
                stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
                stdscr.addnstr(yy, 2, "Overview", w - 4)
                stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)
            else:
                active = (self.tab == val)
                if active:
                    stdscr.attron(curses.color_pair(6) | curses.A_BOLD)
                    stdscr.addnstr(yy, 1, " " * (w - 2), w - 2)
                    stdscr.addnstr(yy, 2, "• " + label, w - 4)
                    stdscr.attroff(curses.color_pair(6) | curses.A_BOLD)
                else:
                    stdscr.attron(curses.color_pair(7))
                    stdscr.addnstr(yy, 2, "  " + label, w - 4)
                    stdscr.attroff(curses.color_pair(7))
            yy += 2

    def draw_summary_cards(self, stdscr, y, x, w):
        # cards: CPU | MEM | DISK | NET  (one row)
        mem_used = self.sysinfo["mem_used"]
        mem_total = self.sysinfo["mem_total"]
        mem_pct = self.sysinfo["mem_pct"]

        d_used = self.sysinfo["disk_used"]
        d_total = self.sysinfo["disk_total"]
        d_pct = self.sysinfo["disk_pct"]

        load1, load5, load15 = self.sysinfo["load"]

        cards = [
            ("CPU", f"{self.cpu_pct:4.1f}%", self.cpu_pct, f"Load {load1} {load5} {load15}"),
            ("MEM", f"{human_bytes(mem_used)} / {human_bytes(mem_total)}", mem_pct, f"{mem_pct:4.1f}% used"),
            ("DSK", f"{human_bytes(d_used)} / {human_bytes(d_total)}", d_pct, f"{d_pct:4.1f}% used"),
            ("NET", f"↓{human_rate(self.rx_rate)}  ↑{human_rate(self.tx_rate)}", 0.0, ""),
        ]

        # sizing
        gap = 2
        cw = max(18, (w - gap * 3) // 4)
        cw = min(cw, 34)

        for i, (name, line1, pct, line2) in enumerate(cards):
            cx = x + i * (cw + gap)
            if cx >= x + w:
                break

            # soft card background
            stdscr.attron(curses.color_pair(8))
            stdscr.addnstr(y, cx, " " * cw, cw)
            stdscr.addnstr(y + 1, cx, " " * cw, cw)
            stdscr.addnstr(y + 2, cx, " " * cw, cw)
            stdscr.addnstr(y + 3, cx, " " * cw, cw)
            stdscr.attroff(curses.color_pair(8))

            # title
            stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
            stdscr.addnstr(y, cx + 1, name, cw - 2)
            stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)

            # value
            stdscr.attron(curses.color_pair(7))
            stdscr.addnstr(y + 1, cx + 1, ellipsize(line1, cw - 2), cw - 2)
            stdscr.attroff(curses.color_pair(7))

            # bar (for non-net)
            if name != "NET":
                bw = cw - 2
                col = curses.color_pair(5 if pct >= 85 else 4 if pct >= 60 else 3 if pct >= 40 else 2)
                stdscr.attron(col)
                stdscr.addnstr(y + 2, cx + 1, bar(bw, pct), bw)
                stdscr.attroff(col)
                stdscr.attron(curses.color_pair(8))
                stdscr.addnstr(y + 3, cx + 1, ellipsize(line2, cw - 2), cw - 2)
                stdscr.attroff(curses.color_pair(8))
            else:
                stdscr.attron(curses.color_pair(8))
                stdscr.addnstr(y + 2, cx + 1, ellipsize(f"Rates (last {int(REFRESH_SEC)}s)", cw - 2), cw - 2)
                stdscr.attroff(curses.color_pair(8))

    def draw_table(self, stdscr, y, x, h, w, dt_last_refresh):
        # header line
        hdr = ["Name", "PID", "CPU", "Mem", "Disk", "User"]
        widths = [int(w * 0.50), int(w * 0.10), int(w * 0.10), int(w * 0.12), int(w * 0.08), int(w * 0.10)]
        # normalize
        s = sum(widths)
        if s != w:
            widths[0] += (w - s)

        stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
        xx = x
        for t, cw in zip(hdr, widths):
            stdscr.addnstr(y, xx, ellipsize(t, cw), cw)
            xx += cw
        stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)

        # divider
        stdscr.attron(curses.color_pair(8))
        stdscr.addnstr(y + 1, x, "─" * w, w)
        stdscr.attroff(curses.color_pair(8))

        rows_y = y + 2
        rows_avail = max(1, h - 3)
        n = len(self.procs)

        # scroll mgmt
        if self.selected < self.scroll:
            self.scroll = self.selected
        if self.selected >= self.scroll + rows_avail:
            self.scroll = self.selected - rows_avail + 1
        self.scroll = clamp(self.scroll, 0, max(0, n - rows_avail))

        visible = self.procs[self.scroll : min(n, self.scroll + min(rows_avail, MAX_VISIBLE_IO))]
        self.update_visible_io([p["pid"] for p in visible], dt_last_refresh)

        # rows
        for i in range(rows_avail):
            idx = self.scroll + i
            yy = rows_y + i
            if yy >= y + h:
                break

            if idx >= n:
                stdscr.addnstr(yy, x, " " * w, w)
                continue

            p = self.procs[idx]
            pid = p["pid"]
            cpu = p["cpu"]
            mem_mb = p["mem_mb"]
            user = p["user"]
            cmd = p["cmd"]

            io_bps = self.io_bps_cache.get(pid, 0.0)
            io_txt = human_rate(io_bps) if io_bps > 0 else "-"

            cols = [
                ellipsize(cmd, widths[0] - 1),
                str(pid),
                f"{cpu:>4.1f}%",
                f"{mem_mb:>6.1f}M",
                io_txt,
                ellipsize(user, widths[5] - 1),
            ]

            selected = (idx == self.selected)
            if selected:
                stdscr.attron(curses.color_pair(6) | curses.A_BOLD)
                stdscr.addnstr(yy, x, " " * w, w)
            else:
                # subtle “heat” on CPU
                col = curses.color_pair(5 if cpu >= 40 else 4 if cpu >= 15 else 7)
                stdscr.attron(col)

            xx = x
            for t, cw in zip(cols, widths):
                stdscr.addnstr(yy, xx, ellipsize(t, cw), cw)
                xx += cw

            if selected:
                stdscr.attroff(curses.color_pair(6) | curses.A_BOLD)
            else:
                stdscr.attroff(col)

        # footer
        footer = f"{n} procs  •  Sort {self.sort_mode}  •  Filter {self.filter_text or '-'}"
        stdscr.attron(curses.color_pair(8))
        stdscr.addnstr(y + h - 1, x, ellipsize(footer, w), w)
        stdscr.attroff(curses.color_pair(8))

    def draw_perf(self, stdscr, y, x, h, w):
        mem_used = self.sysinfo["mem_used"]
        mem_total = self.sysinfo["mem_total"]
        mem_pct = self.sysinfo["mem_pct"]
        d_used = self.sysinfo["disk_used"]
        d_total = self.sysinfo["disk_total"]
        d_pct = self.sysinfo["disk_pct"]
        load1, load5, load15 = self.sysinfo["load"]

        lines = [
            ("CPU", f"{self.cpu_pct:4.1f}%   Load {load1} {load5} {load15}"),
            ("Memory", f"{human_bytes(mem_used)} / {human_bytes(mem_total)}   ({mem_pct:4.1f}%)"),
            ("Disk", f"{human_bytes(d_used)} / {human_bytes(d_total)}   ({d_pct:4.1f}%)"),
            ("Network", f"↓{human_rate(self.rx_rate)}   ↑{human_rate(self.tx_rate)}"),
        ]

        stdscr.attron(curses.color_pair(7))
        for i, (k, v) in enumerate(lines):
            yy = y + i * 2
            if yy >= y + h:
                break
            stdscr.addnstr(yy, x, ellipsize(k, 10), min(10, w))
            stdscr.attron(curses.color_pair(2))
            stdscr.addnstr(yy, x + 12, ellipsize(v, w - 12), w - 12)
            stdscr.attroff(curses.color_pair(2))
        stdscr.attroff(curses.color_pair(7))

    # ---- main loop ----

    def run(self, stdscr):
        curses.curs_set(0)
        stdscr.nodelay(True)
        stdscr.keypad(True)
        self.init_colors()

        # init deltas
        self.prev_cpu_total, self.prev_cpu_idle = read_cpu_total_idle()
        self.prev_rx, self.prev_tx = read_net_bytes_total()
        last_refresh = time.monotonic()
        dt_last_refresh = REFRESH_SEC

        # initial fetch
        self.calc_system(REFRESH_SEC)
        self.build_processes(REFRESH_SEC)

        need_redraw = True

        while True:
            now = time.monotonic()

            # refresh tick
            if now - last_refresh >= REFRESH_SEC:
                dt = now - last_refresh
                last_refresh = now
                dt_last_refresh = max(0.3, dt)
                self.calc_system(dt_last_refresh)
                if self.tab == TAB_PROCESSES:
                    self.build_processes(dt_last_refresh)
                need_redraw = True

            # input
            try:
                ch = stdscr.getch()
            except Exception:
                ch = -1

            if ch != -1:
                # quit
                if ch in (ord("q"), ord("Q")):
                    return

                # switch tab
                if ch == 9:  # TAB
                    self.tab = TAB_PERF if self.tab == TAB_PROCESSES else TAB_PROCESSES
                    need_redraw = True

                # filter
                elif ch == ord("/"):
                    s = self.dialog_filter(stdscr)
                    if s is not None:
                        self.filter_text = s
                        self.selected = 0
                        self.scroll = 0
                        if self.tab == TAB_PROCESSES:
                            self.build_processes(dt_last_refresh)
                        need_redraw = True

                # sort
                elif ch in (ord("s"), ord("S")):
                    self.sort_mode = "MEM" if self.sort_mode == "CPU" else "CPU"
                    if self.tab == TAB_PROCESSES:
                        self.build_processes(dt_last_refresh)
                    need_redraw = True

                # processes nav/actions
                elif self.tab == TAB_PROCESSES:
                    n = len(self.procs)
                    if ch in (curses.KEY_UP,):
                        if self.selected > 0:
                            self.selected -= 1
                            need_redraw = True
                    elif ch in (curses.KEY_DOWN,):
                        if self.selected < max(0, n - 1):
                            self.selected += 1
                            need_redraw = True
                    elif ch == curses.KEY_PPAGE:
                        self.selected = max(0, self.selected - 12)
                        need_redraw = True
                    elif ch == curses.KEY_NPAGE:
                        self.selected = min(max(0, n - 1), self.selected + 12)
                        need_redraw = True
                    elif ch in (ord("k"), ord("K"), curses.KEY_ENTER, 10, 13):
                        if self.procs:
                            pid = self.procs[self.selected]["pid"]
                            sig = self.dialog_kill(stdscr, pid)
                            need_redraw = True
                            if sig is not None:
                                ok, err = self.kill_pid(pid, sig)
                                self.toast(
                                    f"{'TERM' if sig == signal.SIGTERM else 'KILL'} sent to {pid}" if ok else f"Failed: {err}",
                                    2.0
                                )

            # draw
            toast_visible = self.toast_msg and (time.monotonic() < self.toast_until)
            if need_redraw or toast_visible:
                h, w = stdscr.getmaxyx()
                stdscr.erase()

                # header rows (0-1)
                self.draw_header(stdscr, w)

                # layout
                top = 2
                sidebar_w = min(max(16, w // 7), 22)
                content_x = sidebar_w + 2

                # sidebar
                self.draw_sidebar(stdscr, top, h - top, sidebar_w)

                # main
                main_w = w - content_x - 1
                if main_w < 20:
                    stdscr.refresh()
                    time.sleep(0.05)
                    continue

                # summary cards (4 rows)
                self.draw_summary_cards(stdscr, top, content_x, main_w)

                # content area
                content_y = top + 5
                content_h = h - content_y - 1

                if self.tab == TAB_PROCESSES:
                    self.draw_table(stdscr, content_y, content_x, content_h, main_w, dt_last_refresh)
                else:
                    self.draw_perf(stdscr, content_y, content_x, content_h, main_w)

                stdscr.refresh()
                need_redraw = False

            time.sleep(0.03)

def main():
    curses.wrapper(TaskManNeo().run)

if __name__ == "__main__":
    main()
