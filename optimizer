#!/usr/bin/env python3
import os
import sys
import subprocess
import shutil
from datetime import datetime
from typing import List

LOG_FILE = "/var/log/server-baseline-menu.log"

APT_OPTS = [
    "-y",
    "-o", "Dpkg::Options::=--force-confdef",
    "-o", "Dpkg::Options::=--force-confold",
]

BASE_PACKAGES = [
    "ca-certificates", "curl", "gnupg", "lsb-release", "apt-transport-https",
    "software-properties-common",
    "unattended-upgrades", "needrestart",
    "nano", "vim-tiny",
    "htop", "iotop", "iftop", "ncdu",
    "jq",
    "logrotate",
    "openssl"
]

# ---------------- UI (clean + modern) ----------------
RESET   = "\033[0m"
BOLD    = "\033[1m"
DIM     = "\033[2m"
CYAN    = "\033[36m"
GREEN   = "\033[32m"
YELLOW  = "\033[33m"
RED     = "\033[31m"
WHITE   = "\033[37m"

def is_tty() -> bool:
    try:
        return sys.stdout.isatty()
    except Exception:
        return False

def term_width(default=90) -> int:
    try:
        return max(72, shutil.get_terminal_size((default, 24)).columns)
    except Exception:
        return default

def clear_screen():
    if is_tty():
        print("\033[2J\033[H", end="")

def hr(char="─") -> str:
    return char * term_width()

def pause_return():
    input(f"\n{DIM}Press Enter to return...{RESET}")

def print_menu_header(os_name: str, os_ver: str):
    clear_screen()
    print(f"{GREEN}{hr()}{RESET}")
    title = f"{BOLD}{GREEN}Ubuntu Tweaker{RESET}"
    print(title.center(term_width()))
    sub = f"{DIM}{os_name} {os_ver}{RESET}"
    print(sub.center(term_width()))
    print(f"{GREEN}{hr()}{RESET}")
    print(f"{DIM}Log:{RESET} {WHITE}{LOG_FILE}{RESET}\n")

def menu_item(key: str, label: str, hint: str = "") -> str:
    k = f"{CYAN}{key:<2}{RESET}"
    if hint:
        return f" {k}  {WHITE}{label}{RESET}  {DIM}{hint}{RESET}"
    return f" {k}  {WHITE}{label}{RESET}"

# ---------------- Core helpers ----------------
def is_root() -> bool:
    return os.geteuid() == 0

def log(msg: str) -> None:
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{ts}] {msg}"
    print(line)
    try:
        os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(line + "\n")
    except Exception:
        pass

def run(cmd, check=True, env=None):
    if isinstance(cmd, str):
        display = cmd
    else:
        display = " ".join(cmd)
    log(f"RUN: {display}")
    merged_env = os.environ.copy()
    merged_env["DEBIAN_FRONTEND"] = "noninteractive"
    if env:
        merged_env.update(env)
    return subprocess.run(cmd, check=check, env=merged_env)

def header(title: str):
    print(f"\n{BOLD}{CYAN}{title}{RESET}")
    print(f"{DIM}{'-' * 70}{RESET}\n")

def detect_ubuntu():
    name = "unknown"
    ver = "unknown"
    try:
        with open("/etc/os-release", "r", encoding="utf-8") as f:
            data = f.read().splitlines()
        kv = {}
        for line in data:
            if "=" in line:
                k, v = line.split("=", 1)
                kv[k.strip()] = v.strip().strip('"')
        name = kv.get("NAME", "unknown")
        ver = kv.get("VERSION_ID", "unknown")
    except Exception:
        pass
    return name, ver

# ----------------------- Actions -----------------------
def action_update_upgrade_cleanup():
    header("Update + Upgrade + Full-Upgrade + Cleanup")
    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "upgrade"] + APT_OPTS)
    run(["apt-get", "full-upgrade"] + APT_OPTS)
    run(["apt-get", "autoremove", "--purge"] + APT_OPTS)
    run(["apt-get", "autoclean"] + APT_OPTS)
    log("Done.")

def action_install_base_tools():
    header("Install Baseline Tools")
    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "install", "--no-install-recommends"] + APT_OPTS + BASE_PACKAGES)
    log("Done.")

def action_unattended_upgrades():
    header("Enable Automatic Security Updates")
    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "install"] + APT_OPTS + ["unattended-upgrades"])

    auto_up = """APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";
"""
    os.makedirs("/etc/apt/apt.conf.d", exist_ok=True)
    with open("/etc/apt/apt.conf.d/20auto-upgrades", "w", encoding="utf-8") as f:
        f.write(auto_up)

    f50 = "/etc/apt/apt.conf.d/50unattended-upgrades"
    if os.path.exists(f50):
        with open(f50, "r", encoding="utf-8") as f:
            content = f.read()
        if 'Remove-Unused-Dependencies' not in content:
            content += '\nUnattended-Upgrade::Remove-Unused-Dependencies "true";\n'
        if 'Automatic-Reboot' not in content:
            content += '\nUnattended-Upgrade::Automatic-Reboot "false";\n'
        if 'Automatic-Reboot-Time' not in content:
            content += '\nUnattended-Upgrade::Automatic-Reboot-Time "03:30";\n'
        with open(f50, "w", encoding="utf-8") as f:
            f.write(content)
    else:
        with open(f50, "w", encoding="utf-8") as f:
            f.write(
                'Unattended-Upgrade::Remove-Unused-Dependencies "true";\n'
                'Unattended-Upgrade::Automatic-Reboot "false";\n'
                'Unattended-Upgrade::Automatic-Reboot-Time "03:30";\n'
            )

    run(["systemctl", "enable", "--now", "unattended-upgrades"], check=False)
    log("Done.")

def action_journald_limits():
    header("Limit System Logs (journald)")
    os.makedirs("/etc/systemd/journald.conf.d", exist_ok=True)
    cfg = """[Journal]
SystemMaxUse=200M
RuntimeMaxUse=100M
MaxRetentionSec=14day
Compress=yes
"""
    with open("/etc/systemd/journald.conf.d/99-baseline.conf", "w", encoding="utf-8") as f:
        f.write(cfg)

    run(["systemctl", "restart", "systemd-journald"], check=False)
    run(["journalctl", "--vacuum-time=14d"], check=False)
    run(["journalctl", "--vacuum-size=200M"], check=False)
    log("Done.")

def action_enable_fstrim():
    header("Enable SSD Trim (fstrim.timer)")
    res = subprocess.run(["systemctl", "list-unit-files"], capture_output=True, text=True)
    if "fstrim.timer" in (res.stdout or ""):
        run(["systemctl", "enable", "--now", "fstrim.timer"], check=False)
        log("Done.")
    else:
        log("Skip: fstrim.timer not available.")

def action_sysctl_hardening():
    header("Sysctl Hardening")
    cfg = """# Conservative hardening defaults

net.ipv4.conf.all.rp_filter=1
net.ipv4.conf.default.rp_filter=1

net.ipv4.conf.all.accept_redirects=0
net.ipv4.conf.default.accept_redirects=0
net.ipv6.conf.all.accept_redirects=0
net.ipv6.conf.default.accept_redirects=0

net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.default.send_redirects=0

net.ipv4.tcp_syncookies=1

net.ipv4.conf.all.accept_source_route=0
net.ipv4.conf.default.accept_source_route=0
net.ipv6.conf.all.accept_source_route=0
net.ipv6.conf.default.accept_source_route=0

net.ipv4.conf.all.log_martians=1
net.ipv4.conf.default.log_martians=1

kernel.kptr_restrict=2
kernel.dmesg_restrict=1
"""
    os.makedirs("/etc/sysctl.d", exist_ok=True)
    with open("/etc/sysctl.d/99-baseline-hardening.conf", "w", encoding="utf-8") as f:
        f.write(cfg)

    run(["sysctl", "--system"], check=False)
    log("Done.")

def kernel_supports_bbr() -> bool:
    try:
        out = subprocess.check_output(
            ["sysctl", "-n", "net.ipv4.tcp_available_congestion_control"],
            text=True
        ).strip()
        return "bbr" in out.split()
    except Exception:
        return False

def action_network_bbr():
    header("BBR Network Tuning")
    if not kernel_supports_bbr():
        log("BBR not available in this kernel. Skipping.")
        return

    cfg = """# BBR + fq pacing + sane buffers
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr

net.core.rmem_max=8388608
net.core.wmem_max=8388608
net.ipv4.tcp_rmem=4096 87380 8388608
net.ipv4.tcp_wmem=4096 65536 8388608

net.core.somaxconn=1024
net.ipv4.tcp_max_syn_backlog=2048

net.ipv4.ip_local_port_range=10240 65535
net.ipv4.tcp_mtu_probing=1
"""
    os.makedirs("/etc/sysctl.d", exist_ok=True)
    with open("/etc/sysctl.d/99-baseline-bbr.conf", "w", encoding="utf-8") as f:
        f.write(cfg)

    run(["sysctl", "--system"], check=False)
    log("Done.")

def action_create_swap():
    header("Create Swap (RAM expand)")
    show = subprocess.run(["swapon", "--show"], capture_output=True, text=True)
    if (show.stdout or "").strip():
        log("Swap already active. Skipping.")
        return

    size_gb = input("Swap size in GB (example: 2, 0 cancels): ").strip()
    if not size_gb.isdigit():
        log("Invalid input. Cancelled.")
        return
    size_gb_int = int(size_gb)
    if size_gb_int <= 0:
        log("Cancelled.")
        return

    swapfile = "/swapfile"
    log(f"Creating {size_gb_int}G swapfile at {swapfile} ...")

    try:
        run(["fallocate", "-l", f"{size_gb_int}G", swapfile], check=True)
    except Exception:
        run(["dd", "if=/dev/zero", f"of={swapfile}", "bs=1M", f"count={size_gb_int*1024}"], check=True)

    run(["chmod", "600", swapfile], check=True)
    run(["mkswap", swapfile], check=True)
    run(["swapon", swapfile], check=True)

    with open("/etc/fstab", "r", encoding="utf-8") as f:
        fstab = f.read()
    if "/swapfile" not in fstab:
        with open("/etc/fstab", "a", encoding="utf-8") as f:
            f.write("\n/swapfile none swap sw 0 0\n")

    log("Done.")

def action_report():
    header("System Report")
    cmds = [
        ["uname", "-a"],
        ["df", "-hT", "/"],
        ["free", "-h"],
        ["uptime"],
        ["systemd-analyze", "time"],
    ]
    for c in cmds:
        run(c, check=False)
        print()

    log("Slow boot units:")
    run(["bash", "-lc", "systemd-analyze blame | head -n 15"], check=False)
    log(f"Log file: {LOG_FILE}")

def action_release_upgrade_manual():
    header("Ubuntu Release Upgrade (Manual)")
    name, ver = detect_ubuntu()

    if "Ubuntu" not in name:
        log("Ubuntu only. Skipping.")
        return

    # Build options based on current version
    if ver.startswith("20."):
        print(f"{YELLOW}Detected:{RESET} Ubuntu {ver}\n")
        print(f"{WHITE}Choose upgrade target:{RESET}")
        print(menu_item("1", "Upgrade to 22.04 LTS", "recommended"))
        print(menu_item("2", "Upgrade to 24.04 LTS", "not direct from 20.04"))
        print()
        choice = input("Select (1-2) or Q: ").strip().lower()
        if choice in ("q", "quit", "0", "exit"):
            log("Cancelled.")
            return
        if choice == "2":
            print(f"\n{RED}Not supported as a normal direct upgrade from 20.04 → 24.04.{RESET}")
            print(f"{DIM}Do 20.04 → 22.04 first, then run the upgrade again for 24.04.{RESET}")
            return
        target = "22.04 LTS"
    elif ver.startswith("22."):
        print(f"{YELLOW}Detected:{RESET} Ubuntu {ver}\n")
        print(f"{WHITE}Choose upgrade target:{RESET}")
        print(menu_item("1", "Upgrade to 24.04 LTS", "recommended"))
        print()
        choice = input("Select (1) or Q: ").strip().lower()
        if choice in ("q", "quit", "0", "exit"):
            log("Cancelled.")
            return
        if choice != "1":
            print(f"{RED}Invalid choice.{RESET}")
            return
        target = "24.04 LTS"
    elif ver.startswith("24."):
        print(f"{YELLOW}Detected:{RESET} Ubuntu {ver}")
        print(f"{GREEN}You are already on the latest supported version in this tool.{RESET}")
        return
    else:
        log(f"Unsupported Ubuntu version: {ver}")
        return

    print(f"\n{YELLOW}Target:{RESET} {target}")
    print(f"{DIM}This is interactive and must be supervised (tmux/screen + snapshot recommended).{RESET}\n")

    ans = input("Type YES to start: ").strip()
    if ans != "YES":
        log("Cancelled.")
        return

    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "install"] + APT_OPTS + ["update-manager-core"])
    log("Pre-upgrade update...")
    action_update_upgrade_cleanup()

    run(["do-release-upgrade", "-c"], check=False)
    log("Starting do-release-upgrade...")
    run(["do-release-upgrade"], check=False)

def action_run_all():
    header("Run Everything")
    # NOTE: This does NOT include release upgrade. Upgrade stays manual.
    action_update_upgrade_cleanup()
    action_install_base_tools()
    action_unattended_upgrades()
    action_enable_fstrim()
    action_journald_limits()
    action_sysctl_hardening()

    ans = input("Enable BBR? (y/N): ").strip().lower()
    if ans == "y":
        action_network_bbr()

    ans = input("Create swap? (y/N): ").strip().lower()
    if ans == "y":
        action_create_swap()

    action_update_upgrade_cleanup()
    action_report()
    log("Done. (Release upgrade is manual only)")

# ----------------------- Menu -----------------------
def menu():
    while True:
        os_name, os_ver = detect_ubuntu()
        print_menu_header(os_name, os_ver)

        print(f"{BOLD}{WHITE}Main{RESET}")
        print(menu_item("1", "Run everything", "does not include release upgrade"))
        print()

        print(f"{BOLD}{WHITE}Maintenance{RESET}")
        print(menu_item("2", "Update + upgrade + cleanup"))
        print(menu_item("3", "Install baseline tools"))
        print(menu_item("4", "Enable automatic security updates"))
        print(menu_item("5", "Limit system logs (journald)"))
        print(menu_item("6", "Enable SSD trim (fstrim)"))
        print()

        print(f"{BOLD}{WHITE}Tuning{RESET}")
        print(menu_item("7", "Sysctl hardening"))
        print(menu_item("8", "Enable BBR network tuning"))
        print(menu_item("9", "Create swap (RAM expand)"))
        print()

        print(f"{BOLD}{WHITE}Tools{RESET}")
        print(menu_item("R", "System report"))
        print(menu_item("U", "Ubuntu release upgrade", "manual / interactive"))
        print()

        print(f"{DIM}{hr('─')}{RESET}")
        choice = input(f"{BOLD}Select{RESET} {DIM}(1-9, R, U, Q){RESET}: ").strip().lower()

        if choice in ("q", "quit", "0", "exit"):
            clear_screen()
            log("Exit.")
            return

        clear_screen()
        try:
            if choice == "1": action_run_all()
            elif choice == "2": action_update_upgrade_cleanup()
            elif choice == "3": action_install_base_tools()
            elif choice == "4": action_unattended_upgrades()
            elif choice == "5": action_journald_limits()
            elif choice == "6": action_enable_fstrim()
            elif choice == "7": action_sysctl_hardening()
            elif choice == "8": action_network_bbr()
            elif choice == "9": action_create_swap()
            elif choice == "r": action_report()
            elif choice == "u": action_release_upgrade_manual()
            else:
                print(f"{RED}Invalid choice.{RESET}")
        except subprocess.CalledProcessError as e:
            log(f"Command failed: {e}")
        except Exception as e:
            log(f"Error: {e}")

        pause_return()

def main():
    if not is_root():
        print("Run as root (sudo). Example:\n  sudo ./optimizer")
        sys.exit(1)
    menu()

if __name__ == "__main__":
    main()
