#!/usr/bin/env python3
import os
import sys
import time
import signal
import subprocess
import shutil
from datetime import datetime
from typing import List, Optional

LOG_FILE = "/var/log/server-baseline-menu.log"

APT_OPTS = [
    "-y",
    "-o", "Dpkg::Options::=--force-confdef",
    "-o", "Dpkg::Options::=--force-confold",
]

BASE_PACKAGES = [
    "ca-certificates", "curl", "gnupg", "lsb-release", "apt-transport-https",
    "software-properties-common",
    "unattended-upgrades", "needrestart",
    "nano", "vim-tiny",
    "htop", "iotop", "iftop", "ncdu",
    "jq",
    "logrotate",
    "openssl"
]

# ---------------- UI (clean + modern) ----------------
RESET   = "\033[0m"
BOLD    = "\033[1m"
DIM     = "\033[2m"
CYAN    = "\033[36m"
GREEN   = "\033[32m"
YELLOW  = "\033[33m"
RED     = "\033[31m"
WHITE   = "\033[37m"

def is_tty() -> bool:
    try:
        return sys.stdout.isatty()
    except Exception:
        return False

def term_width(default=90) -> int:
    try:
        return max(72, shutil.get_terminal_size((default, 24)).columns)
    except Exception:
        return default

def clear_screen():
    if is_tty():
        print("\033[2J\033[H", end="")

def hr(char="─") -> str:
    return char * term_width()

def pause_return():
    input(f"\n{DIM}Press Enter to return...{RESET}")

def print_menu_header(os_name: str, os_ver: str):
    clear_screen()
    print(f"{GREEN}{hr()}{RESET}")
    title = f"{BOLD}{GREEN}Ubuntu Tweaker{RESET}"
    print(title.center(term_width()))
    sub = f"{DIM}{os_name} {os_ver}{RESET}"
    print(sub.center(term_width()))
    print(f"{GREEN}{hr()}{RESET}\n")

def menu_item(key: str, label: str, hint: str = "") -> str:
    k = f"{CYAN}{key:<2}{RESET}"
    if hint:
        return f" {k}  {WHITE}{label}{RESET}  {DIM}{hint}{RESET}"
    return f" {k}  {WHITE}{label}{RESET}"

# ---------------- Core helpers ----------------
def is_root() -> bool:
    return os.geteuid() == 0

def log(msg: str) -> None:
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{ts}] {msg}"
    print(line)
    try:
        os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(line + "\n")
    except Exception:
        pass

def run(cmd, check=True, env=None, capture=False, text=True):
    if isinstance(cmd, str):
        display = cmd
    else:
        display = " ".join(cmd)
    log(f"RUN: {display}")
    merged_env = os.environ.copy()
    merged_env["DEBIAN_FRONTEND"] = "noninteractive"
    if env:
        merged_env.update(env)
    return subprocess.run(
        cmd,
        check=check,
        env=merged_env,
        capture_output=capture,
        text=text
    )

def header(title: str):
    print(f"\n{BOLD}{CYAN}{title}{RESET}")
    print(f"{DIM}{'-' * 70}{RESET}\n")

def detect_ubuntu():
    name = "unknown"
    ver = "unknown"
    try:
        with open("/etc/os-release", "r", encoding="utf-8") as f:
            data = f.read().splitlines()
        kv = {}
        for line in data:
            if "=" in line:
                k, v = line.split("=", 1)
                kv[k.strip()] = v.strip().strip('"')
        name = kv.get("NAME", "unknown")
        ver = kv.get("VERSION_ID", "unknown")
    except Exception:
        pass
    return name, ver

def cmd_out(cmd: List[str]) -> str:
    try:
        r = subprocess.run(cmd, capture_output=True, text=True)
        return (r.stdout or "").strip()
    except Exception:
        return ""

def which(bin_name: str) -> bool:
    return shutil.which(bin_name) is not None

# ---------------- Task Monitor helpers ----------------
def get_default_iface() -> Optional[str]:
    # Try default route interface
    out = cmd_out(["bash", "-lc", "ip route | awk '/default/ {print $5; exit}'"])
    out = out.strip()
    return out if out else None

def get_cpu_line_from_top() -> str:
    # Example: "%Cpu(s):  1.0 us,  0.5 sy,  0.0 ni, 98.2 id, ..."
    out = cmd_out(["bash", "-lc", "top -bn1 | sed -n '3p'"])
    return out

def get_mem_line_from_free() -> str:
    # Example: "Mem:  987Mi  123Mi  456Mi ..."
    out = cmd_out(["bash", "-lc", "free -h | awk 'NR==2{print \"Mem: used=\" $3 \"/\" $2 \", free=\" $4 \", avail=\" $7}'"])
    return out

def get_disk_line() -> str:
    out = cmd_out(["bash", "-lc", "df -hT / | awk 'NR==2{print \"Disk(/): used=\" $4 \"/\" $3 \", avail=\" $5 \", fs=\" $2}'"])
    return out

def get_uptime_line() -> str:
    out = cmd_out(["bash", "-lc", "uptime -p 2>/dev/null || uptime"])
    out2 = cmd_out(["bash", "-lc", "cat /proc/loadavg | awk '{print \"load:\" $1 \",\" $2 \",\" $3}'"])
    if out2:
        return f"{out}  |  {out2}"
    return out

def get_net_line(iface: Optional[str]) -> str:
    if not iface:
        return "Net: (no default interface found)"
    # RX/TX bytes from ip -s link
    # We compute human-ish in bash
    script = r"""
iface="$1"
rx=$(cat /sys/class/net/"$iface"/statistics/rx_bytes 2>/dev/null || echo 0)
tx=$(cat /sys/class/net/"$iface"/statistics/tx_bytes 2>/dev/null || echo 0)

h() {
  b=$1
  if [ "$b" -lt 1024 ]; then echo "${b}B"; return; fi
  kb=$((b/1024))
  if [ "$kb" -lt 1024 ]; then echo "${kb}KiB"; return; fi
  mb=$((kb/1024))
  if [ "$mb" -lt 1024 ]; then echo "${mb}MiB"; return; fi
  gb=$((mb/1024))
  echo "${gb}GiB"
}

echo "Net($iface): RX=$(h "$rx")  TX=$(h "$tx")"
"""
    out = cmd_out(["bash", "-lc", script, "bash", iface])
    return out if out else f"Net({iface}): (stats unavailable)"

def get_top_processes(sort_by: str = "cpu", limit: int = 12) -> str:
    # sort_by: "cpu" or "mem"
    if sort_by == "mem":
        cmd = "ps -eo pid,user,pmem,pcpu,etime,comm --sort=-pmem | head -n {}".format(limit)
    else:
        cmd = "ps -eo pid,user,pcpu,pmem,etime,comm --sort=-pcpu | head -n {}".format(limit)
    out = cmd_out(["bash", "-lc", cmd])
    return out

def show_process(pid: int) -> str:
    out = cmd_out(["bash", "-lc", f"ps -p {pid} -o pid,user,pcpu,pmem,etime,cmd --no-headers"])
    return out

def kill_process(pid: int, force: bool = False) -> bool:
    try:
        os.kill(pid, signal.SIGKILL if force else signal.SIGTERM)
        return True
    except Exception:
        return False

def action_task_monitor():
    iface = get_default_iface()
    sort_mode = "cpu"  # cpu or mem

    while True:
        clear_screen()
        print(f"{GREEN}{hr()}{RESET}")
        print(f"{BOLD}{GREEN}Task Monitor{RESET}".center(term_width()))
        sub = f"{DIM}Refresh: R  |  Sort: S  |  Kill: K  |  htop/top: H  |  Back: Q{RESET}"
        print(sub.center(term_width()))
        print(f"{GREEN}{hr()}{RESET}\n")

        # Summary
        uptime_line = get_uptime_line()
        cpu_line = get_cpu_line_from_top()
        mem_line = get_mem_line_from_free()
        disk_line = get_disk_line()
        net_line = get_net_line(iface)

        print(f"{WHITE}{uptime_line}{RESET}")
        if cpu_line:
            print(f"{WHITE}{cpu_line}{RESET}")
        print(f"{WHITE}{mem_line}{RESET}")
        print(f"{WHITE}{disk_line}{RESET}")
        print(f"{WHITE}{net_line}{RESET}")
        print(f"\n{DIM}{hr('─')}{RESET}\n")

        # Processes
        title = "Top processes (CPU)" if sort_mode == "cpu" else "Top processes (MEM)"
        print(f"{BOLD}{WHITE}{title}{RESET}  {DIM}(PID USER %CPU %MEM TIME CMD){RESET}\n")
        print(get_top_processes(sort_by=sort_mode, limit=14))
        print(f"\n{DIM}{hr('─')}{RESET}")

        choice = input(f"{BOLD}Command{RESET} {DIM}(R/S/K/H/Q){RESET}: ").strip().lower()

        if choice in ("q", "quit", "back", "0"):
            return

        if choice in ("r", ""):
            continue

        if choice == "s":
            sort_mode = "mem" if sort_mode == "cpu" else "cpu"
            continue

        if choice == "h":
            # Open htop if available, else top
            clear_screen()
            if which("htop"):
                subprocess.run(["htop"])
            else:
                subprocess.run(["top"])
            continue

        if choice == "k":
            pid_str = input("PID to terminate (or blank to cancel): ").strip()
            if not pid_str:
                continue
            if not pid_str.isdigit():
                print(f"{RED}Invalid PID.{RESET}")
                time.sleep(1.2)
                continue
            pid = int(pid_str)

            info = show_process(pid)
            if not info:
                print(f"{RED}PID not found (or permission denied).{RESET}")
                time.sleep(1.3)
                continue

            print(f"\n{YELLOW}Target:{RESET} {info}")
            print(f"{DIM}This can break services. Use TERM first; KILL only if needed.{RESET}\n")

            confirm = input("Type TERM to send SIGTERM, KILL for SIGKILL, or cancel: ").strip().upper()
            if confirm == "TERM":
                ok = kill_process(pid, force=False)
                print(f"{GREEN}SIGTERM sent.{RESET}" if ok else f"{RED}Failed to send SIGTERM.{RESET}")
                time.sleep(1.2)
            elif confirm == "KILL":
                ok = kill_process(pid, force=True)
                print(f"{GREEN}SIGKILL sent.{RESET}" if ok else f"{RED}Failed to send SIGKILL.{RESET}")
                time.sleep(1.2)
            else:
                continue

# ----------------------- Baseline actions -----------------------
def action_update_upgrade_cleanup():
    header("Update + Upgrade + Full-Upgrade + Cleanup")
    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "upgrade"] + APT_OPTS)
    run(["apt-get", "full-upgrade"] + APT_OPTS)
    run(["apt-get", "autoremove", "--purge"] + APT_OPTS)
    run(["apt-get", "autoclean"] + APT_OPTS)
    log("Done.")

def action_install_base_tools():
    header("Install Baseline Tools")
    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "install", "--no-install-recommends"] + APT_OPTS + BASE_PACKAGES)
    log("Done.")

def action_unattended_upgrades():
    header("Enable Automatic Security Updates")
    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "install"] + APT_OPTS + ["unattended-upgrades"])

    auto_up = """APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";
"""
    os.makedirs("/etc/apt/apt.conf.d", exist_ok=True)
    with open("/etc/apt/apt.conf.d/20auto-upgrades", "w", encoding="utf-8") as f:
        f.write(auto_up)

    f50 = "/etc/apt/apt.conf.d/50unattended-upgrades"
    if os.path.exists(f50):
        with open(f50, "r", encoding="utf-8") as f:
            content = f.read()
        if 'Remove-Unused-Dependencies' not in content:
            content += '\nUnattended-Upgrade::Remove-Unused-Dependencies "true";\n'
        if 'Automatic-Reboot' not in content:
            content += '\nUnattended-Upgrade::Automatic-Reboot "false";\n'
        if 'Automatic-Reboot-Time' not in content:
            content += '\nUnattended-Upgrade::Automatic-Reboot-Time "03:30";\n'
        with open(f50, "w", encoding="utf-8") as f:
            f.write(content)
    else:
        with open(f50, "w", encoding="utf-8") as f:
            f.write(
                'Unattended-Upgrade::Remove-Unused-Dependencies "true";\n'
                'Unattended-Upgrade::Automatic-Reboot "false";\n'
                'Unattended-Upgrade::Automatic-Reboot-Time "03:30";\n'
            )

    run(["systemctl", "enable", "--now", "unattended-upgrades"], check=False)
    log("Done.")

def action_journald_limits():
    header("Limit System Logs (journald)")
    os.makedirs("/etc/systemd/journald.conf.d", exist_ok=True)
    cfg = """[Journal]
SystemMaxUse=200M
RuntimeMaxUse=100M
MaxRetentionSec=14day
Compress=yes
"""
    with open("/etc/systemd/journald.conf.d/99-baseline.conf", "w", encoding="utf-8") as f:
        f.write(cfg)

    run(["systemctl", "restart", "systemd-journald"], check=False)
    run(["journalctl", "--vacuum-time=14d"], check=False)
    run(["journalctl", "--vacuum-size=200M"], check=False)
    log("Done.")

def action_enable_fstrim():
    header("Enable SSD Trim (fstrim.timer)")
    res = subprocess.run(["systemctl", "list-unit-files"], capture_output=True, text=True)
    if "fstrim.timer" in (res.stdout or ""):
        run(["systemctl", "enable", "--now", "fstrim.timer"], check=False)
        log("Done.")
    else:
        log("Skip: fstrim.timer not available.")

def action_sysctl_hardening():
    header("Sysctl Hardening")
    cfg = """# Conservative hardening defaults

net.ipv4.conf.all.rp_filter=1
net.ipv4.conf.default.rp_filter=1

net.ipv4.conf.all.accept_redirects=0
net.ipv4.conf.default.accept_redirects=0
net.ipv6.conf.all.accept_redirects=0
net.ipv6.conf.default.accept_redirects=0

net.ipv4.conf.all.send_redirects=0
net.ipv4.conf.default.send_redirects=0

net.ipv4.tcp_syncookies=1

net.ipv4.conf.all.accept_source_route=0
net.ipv4.conf.default.accept_source_route=0
net.ipv6.conf.all.accept_source_route=0
net.ipv6.conf.default.accept_source_route=0

net.ipv4.conf.all.log_martians=1
net.ipv4.conf.default.log_martians=1

kernel.kptr_restrict=2
kernel.dmesg_restrict=1
"""
    os.makedirs("/etc/sysctl.d", exist_ok=True)
    with open("/etc/sysctl.d/99-baseline-hardening.conf", "w", encoding="utf-8") as f:
        f.write(cfg)

    run(["sysctl", "--system"], check=False)
    log("Done.")

def kernel_supports_bbr() -> bool:
    try:
        out = subprocess.check_output(
            ["sysctl", "-n", "net.ipv4.tcp_available_congestion_control"],
            text=True
        ).strip()
        return "bbr" in out.split()
    except Exception:
        return False

def action_network_bbr():
    header("BBR Network Tuning")
    if not kernel_supports_bbr():
        log("BBR not available in this kernel. Skipping.")
        return

    cfg = """# BBR + fq pacing + sane buffers
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr

net.core.rmem_max=8388608
net.core.wmem_max=8388608
net.ipv4.tcp_rmem=4096 87380 8388608
net.ipv4.tcp_wmem=4096 65536 8388608

net.core.somaxconn=1024
net.ipv4.tcp_max_syn_backlog=2048

net.ipv4.ip_local_port_range=10240 65535
net.ipv4.tcp_mtu_probing=1
"""
    os.makedirs("/etc/sysctl.d", exist_ok=True)
    with open("/etc/sysctl.d/99-baseline-bbr.conf", "w", encoding="utf-8") as f:
        f.write(cfg)

    run(["sysctl", "--system"], check=False)
    log("Done.")

def action_create_swap():
    header("Create Swap (RAM expand)")
    show = subprocess.run(["swapon", "--show"], capture_output=True, text=True)
    if (show.stdout or "").strip():
        log("Swap already active. Skipping.")
        return

    size_gb = input("Swap size in GB (example: 2, 0 cancels): ").strip()
    if not size_gb.isdigit():
        log("Invalid input. Cancelled.")
        return
    size_gb_int = int(size_gb)
    if size_gb_int <= 0:
        log("Cancelled.")
        return

    swapfile = "/swapfile"
    log(f"Creating {size_gb_int}G swapfile at {swapfile} ...")

    try:
        run(["fallocate", "-l", f"{size_gb_int}G", swapfile], check=True)
    except Exception:
        run(["dd", "if=/dev/zero", f"of={swapfile}", "bs=1M", f"count={size_gb_int*1024}"], check=True)

    run(["chmod", "600", swapfile], check=True)
    run(["mkswap", swapfile], check=True)
    run(["swapon", swapfile], check=True)

    with open("/etc/fstab", "r", encoding="utf-8") as f:
        fstab = f.read()
    if "/swapfile" not in fstab:
        with open("/etc/fstab", "a", encoding="utf-8") as f:
            f.write("\n/swapfile none swap sw 0 0\n")

    log("Done.")

def action_report():
    header("System Report")
    cmds = [
        ["uname", "-a"],
        ["df", "-hT", "/"],
        ["free", "-h"],
        ["uptime"],
        ["systemd-analyze", "time"],
    ]
    for c in cmds:
        run(c, check=False)
        print()

    log("Slow boot units:")
    run(["bash", "-lc", "systemd-analyze blame | head -n 15"], check=False)

def action_release_upgrade_manual():
    header("Ubuntu Release Upgrade (Manual)")
    name, ver = detect_ubuntu()

    if "Ubuntu" not in name:
        log("Ubuntu only. Skipping.")
        return

    if ver.startswith("20."):
        print(f"{YELLOW}Detected:{RESET} Ubuntu {ver}\n")
        print(f"{WHITE}Choose upgrade target:{RESET}")
        print(menu_item("1", "Upgrade to 22.04 LTS", "recommended"))
        print(menu_item("2", "Upgrade to 24.04 LTS", "not direct from 20.04"))
        print()
        choice = input("Select (1-2) or Q: ").strip().lower()
        if choice in ("q", "quit", "0", "exit"):
            log("Cancelled.")
            return
        if choice == "2":
            print(f"\n{RED}Not supported as a normal direct upgrade from 20.04 → 24.04.{RESET}")
            print(f"{DIM}Do 20.04 → 22.04 first, then run the upgrade again for 24.04.{RESET}")
            return
        if choice != "1":
            print(f"{RED}Invalid choice.{RESET}")
            return
        target = "22.04 LTS"
    elif ver.startswith("22."):
        print(f"{YELLOW}Detected:{RESET} Ubuntu {ver}\n")
        print(f"{WHITE}Choose upgrade target:{RESET}")
        print(menu_item("1", "Upgrade to 24.04 LTS", "recommended"))
        print()
        choice = input("Select (1) or Q: ").strip().lower()
        if choice in ("q", "quit", "0", "exit"):
            log("Cancelled.")
            return
        if choice != "1":
            print(f"{RED}Invalid choice.{RESET}")
            return
        target = "24.04 LTS"
    elif ver.startswith("24."):
        print(f"{YELLOW}Detected:{RESET} Ubuntu {ver}")
        print(f"{GREEN}You are already on the latest supported version in this tool.{RESET}")
        return
    else:
        log(f"Unsupported Ubuntu version: {ver}")
        return

    print(f"\n{YELLOW}Target:{RESET} {target}")
    print(f"{DIM}Interactive + must be supervised (tmux/screen + snapshot recommended).{RESET}\n")

    ans = input("Type YES to start: ").strip()
    if ans != "YES":
        log("Cancelled.")
        return

    run(["apt-get", "update"] + APT_OPTS)
    run(["apt-get", "install"] + APT_OPTS + ["update-manager-core"])
    log("Pre-upgrade update...")
    action_update_upgrade_cleanup()

    run(["do-release-upgrade", "-c"], check=False)
    log("Starting do-release-upgrade...")
    run(["do-release-upgrade"], check=False)

def action_run_all():
    header("Run Everything")
    # NOTE: does NOT include release upgrade (manual only)
    action_update_upgrade_cleanup()
    action_install_base_tools()
    action_unattended_upgrades()
    action_enable_fstrim()
    action_journald_limits()
    action_sysctl_hardening()

    ans = input("Enable BBR? (y/N): ").strip().lower()
    if ans == "y":
        action_network_bbr()

    ans = input("Create swap? (y/N): ").strip().lower()
    if ans == "y":
        action_create_swap()

    action_update_upgrade_cleanup()
    action_report()
    log("Done. (Release upgrade is manual only)")

# ----------------------- Menu -----------------------
def menu():
    while True:
        os_name, os_ver = detect_ubuntu()
        print_menu_header(os_name, os_ver)

        print(f"{BOLD}{WHITE}Main{RESET}")
        print(menu_item("1", "Run everything", "does not include release upgrade"))
        print(menu_item("2", "Task monitor", "CPU/RAM/Disk/Net + kill by PID"))
        print()

        print(f"{BOLD}{WHITE}Maintenance{RESET}")
        print(menu_item("3", "Update + upgrade + cleanup"))
        print(menu_item("4", "Install baseline tools"))
        print(menu_item("5", "Enable automatic security updates"))
        print(menu_item("6", "Limit system logs (journald)"))
        print(menu_item("7", "Enable SSD trim (fstrim)"))
        print()

        print(f"{BOLD}{WHITE}Tuning{RESET}")
        print(menu_item("8", "Sysctl hardening"))
        print(menu_item("9", "Enable BBR network tuning"))
        print(menu_item("10", "Create swap (RAM expand)"))
        print()

        print(f"{BOLD}{WHITE}Tools{RESET}")
        print(menu_item("R", "System report"))
        print(menu_item("U", "Ubuntu release upgrade", "manual / interactive"))
        print()

        print(f"{DIM}{hr('─')}{RESET}")
        choice = input(f"{BOLD}Select{RESET} {DIM}(1-10, R, U, Q){RESET}: ").strip().lower()

        if choice in ("q", "quit", "0", "exit"):
            clear_screen()
            log("Exit.")
            return

        clear_screen()
        try:
            if choice == "1": action_run_all()
            elif choice == "2": action_task_monitor()
            elif choice == "3": action_update_upgrade_cleanup()
            elif choice == "4": action_install_base_tools()
            elif choice == "5": action_unattended_upgrades()
            elif choice == "6": action_journald_limits()
            elif choice == "7": action_enable_fstrim()
            elif choice == "8": action_sysctl_hardening()
            elif choice == "9": action_network_bbr()
            elif choice == "10": action_create_swap()
            elif choice == "r": action_report()
            elif choice == "u": action_release_upgrade_manual()
            else:
                print(f"{RED}Invalid choice.{RESET}")
        except subprocess.CalledProcessError as e:
            log(f"Command failed: {e}")
        except Exception as e:
            log(f"Error: {e}")

        pause_return()

def main():
    if not is_root():
        print("Run as root (sudo). Example:\n  sudo ./optimizer")
        sys.exit(1)
    menu()

if __name__ == "__main__":
    main()
